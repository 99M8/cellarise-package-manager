[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/autoUpdateMocha.js",
    "memberof": null,
    "longname": "lib/reports/autoUpdateMocha.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Auto update mocha report\n * @exports reports/autoUpdateMocha\n * @returns {Object} Auto update mocha report functions\n */\nmodule.exports = function autoUpdateMocha() {\n  var base = require(\"./baseMocha\")();\n  var exports = {\n    /**\n     * Prepare the report header\n     * @param {String} [start=new global.Date()] - start time and date\n     * @param {String} [end=new global.Date()] - end time and date (will be overwritten by write report function)\n     * @returns {Object} the report header\n     */\n    \"prepare\": base.prepare,\n    /**\n     * Write a new test\n     * @param {Object} workflowHistory - the workflow history returned from an auto update\n     * @param {Object} rpt - the report object to write or add the test result to\n     */\n    \"write\": function writeReport(workflowHistory, rpt) {\n      var projectDefinition;\n      var pass = true;\n\n      if (workflowHistory.bambooTest && !workflowHistory.bambooTest.successful) {\n        pass = false;\n      }\n      if (workflowHistory.bambooRelease && !workflowHistory.bambooRelease.successful) {\n        pass = false;\n      }\n      //workflow history properties may be incomplete in the event of an error during auto update\n      workflowHistory.project = workflowHistory.project ? workflowHistory.project : {};\n      workflowHistory.updateCheck = workflowHistory.updateCheck ? workflowHistory.updateCheck : {};\n      workflowHistory.updateCheckText = workflowHistory.updateCheckText ? workflowHistory.updateCheckText : {};\n      workflowHistory.updateSourceJiraIssue = workflowHistory.updateSourceJiraIssue ?\n          workflowHistory.updateSourceJiraIssue : {};\n      workflowHistory.bambooTest = workflowHistory.bambooTest ? workflowHistory.bambooTest : {};\n      workflowHistory.bambooRelease = workflowHistory.bambooRelease ? workflowHistory.bambooRelease : {};\n      workflowHistory.transitionedIssue = workflowHistory.transitionedIssue ? workflowHistory.transitionedIssue : {};\n      workflowHistory.releasedVersion = workflowHistory.releasedVersion ? workflowHistory.releasedVersion : {};\n\n      projectDefinition = workflowHistory.project.key + \"-\" + workflowHistory.project.name;\n\n      if (pass) {\n        base.write(projectDefinition, true, {\n          \"title\": projectDefinition,\n          \"fullTitle\": projectDefinition,\n          \"duration\": 0\n        }, rpt);\n      } else {\n        base.write(projectDefinition, false, {\n          \"title\": projectDefinition,\n          \"fullTitle\": projectDefinition,\n          \"duration\": 0,\n          \"error\": projectDefinition + \": \\n\" +\n            \"Update required=\" + workflowHistory.updateCheck + \"\\n\" +\n            \"Jira issue=\" + workflowHistory.updateSourceJiraIssue.key + \"\\n\" +\n            \"Test Build=\" + workflowHistory.bambooTest.buildNumber + \" - \" +\n            workflowHistory.bambooTest.buildState + \"\\n\" +\n            \"Release version=\" + workflowHistory.releasedVersion.name + \"\\n\" +\n            \"Unresolved issues=\" + workflowHistory.releasedVersion.issuesUnresolvedCount + \"\\n\" +\n            \"Release Build=\" + workflowHistory.bambooRelease.buildNumber + \" - \" +\n            workflowHistory.bambooRelease.buildState + \"\\n\"\n        }, rpt);\n      }\n      //no return - rpt past by reference\n    },\n    /**\n     * Synchronously write a test report to a file location\n     * @param {String} reportPath - the file path including filename\n     * @param {Object} report - the report object containing report header and results\n     */\n    \"writeToFileSync\": base.writeToFileSync\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 1,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/autoUpdateMocha.js",
    "longname": "lib/reports/autoUpdateMocha.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/autoUpdateMocha.js",
    "importStyle": null,
    "description": "Auto update mocha report",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/autoUpdateMocha"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Auto update mocha report functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Auto update mocha report functions"
    },
    "generator": false
  },
  {
    "__docId__": 2,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/baseCucumber.js",
    "memberof": null,
    "longname": "lib/reports/baseCucumber.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Base methods for cucumber reports\n * @exports reports/baseCucumber\n * @returns {Object} Base cucumber report functions\n */\nmodule.exports = function baseCucumber() {\n  var currentSuite = \"\";\n  var fs = require(\"fs\");\n  var path = require(\"path\");\n  var mkdirp = require(\"mkdirp\");\n\n  var exports = {\n    /**\n     * Prepare the report header\n     * @param {String} type - the test report type (e.g. feature, bug)\n     * @param {String} name - the test report name\n     * @param {String} description - the test report description\n     * @returns {Object} the report header\n     */\n    \"prepare\": function prepare(type, name, description) {\n      var nameNoSpaces = name.replace(/\\s/g, \"-\");\n      return [\n        {\n          \"id\": nameNoSpaces + \"-\" + type,\n          \"uri\": type + \"s/\" + nameNoSpaces + \".feature\",\n          \"keyword\": type,\n          \"name\": name,\n          \"line\": 1,\n          \"description\": description,\n          \"elements\": []\n        }\n      ];\n    },\n    /**\n     * Write a new test\n     * @param {String} suite - the test suite name\n     * @param {Boolean} pass - has the test passed?\n     * @param {String} message - the test description message\n     * @param {Object} rpt - the report object to write or add the test result to\n     */\n    \"write\": function writeTest(suite, pass, message, rpt) {\n      //increment suite based on opt.suite\n      if (currentSuite !== suite) {\n        rpt.stats.suites = rpt.stats.suites + 1;\n        currentSuite = suite;\n      }\n      rpt.stats.tests = rpt.stats.tests + 1;\n\n      if (pass) {\n        rpt.stats.passes = rpt.stats.passes + 1;\n        rpt.passes.push(message);\n      } else {\n        rpt.stats.failures = rpt.stats.failures + 1;\n        rpt.failures.push(message);\n      }\n\n      rpt.stats.end = new global.Date();\n      rpt.stats.duration = (rpt.stats.end - rpt.stats.start) / 1000;\n      //no return - rpt past by reference\n    },\n    /**\n     * Synchronously write a test report to a file location\n     * @param {String} reportPath - the file path including filename\n     * @param {Object} report - the report object containing report header and results\n     */\n    \"writeToFileSync\": function writeToFileSync(reportPath, report) {\n      var cucumberReport;\n      if (fs.existsSync(reportPath)){\n        cucumberReport = JSON.parse(fs.readFileSync(reportPath, \"utf8\"));\n        cucumberReport.push(report[0]);\n      } else {\n        mkdirp.sync(path.dirname(reportPath)); //make sure the Reports directory exists\n        cucumberReport = report;\n      }\n      fs.writeFileSync(reportPath, JSON.stringify(cucumberReport, null, 2));\n    }\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 3,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/baseCucumber.js",
    "longname": "lib/reports/baseCucumber.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/baseCucumber.js",
    "importStyle": null,
    "description": "Base methods for cucumber reports",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/baseCucumber"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Base cucumber report functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Base cucumber report functions"
    },
    "generator": false
  },
  {
    "__docId__": 4,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/baseMocha.js",
    "memberof": null,
    "longname": "lib/reports/baseMocha.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Base methods for mocha reports\n * @exports reports/baseMocha\n * @returns {Object} Base mocha report functions\n */\nmodule.exports = function baseMocha() {\n  var currentSuite = \"\";\n\n  var exports = {\n    /**\n     * Prepare the report header\n     * @param {String} [start=new global.Date()] - start time and date\n     * @param {String} [end=new global.Date()] - end time and date (will be overwritten by write report function)\n     * @returns {Object} the report header\n     */\n    \"prepare\": function prepare(start, end) {\n      start = start || new global.Date();\n      end = end || new global.Date();\n      return {\n        \"stats\": {\n          \"suites\": 0,\n          \"tests\": 0,\n          \"passes\": 0,\n          \"pending\": 0,\n          \"failures\": 0,\n          \"start\": start,\n          \"end\": end,\n          \"duration\": 0\n        },\n        \"failures\": [],\n        \"passes\": [],\n        \"skipped\": []\n      };\n    },\n    /**\n     * Write a new test\n     * @param {String} suite - the test suite name\n     * @param {Boolean} pass - has the test passed?\n     * @param {String} message - the test description message\n     * @param {Object} rpt - the report object to write or add the test result to\n     */\n    \"write\": function writeTest(suite, pass, message, rpt) {\n      //increment suite based on opt.suite\n      if (currentSuite !== suite) {\n        rpt.stats.suites = rpt.stats.suites + 1;\n        currentSuite = suite;\n      }\n      rpt.stats.tests = rpt.stats.tests + 1;\n\n      if (pass) {\n        rpt.stats.passes = rpt.stats.passes + 1;\n        rpt.passes.push(message);\n      } else {\n        rpt.stats.failures = rpt.stats.failures + 1;\n        rpt.failures.push(message);\n      }\n\n      rpt.stats.end = new global.Date();\n      rpt.stats.duration = (rpt.stats.end - rpt.stats.start) / 1000;\n      //no return - rpt past by reference\n    },\n    /**\n     * Synchronously write a test report to a file location\n     * @param {String} reportPath - the file path including filename\n     * @param {Object} report - the report object containing report header and results\n     */\n    \"writeToFileSync\": function writeToFileSync(reportPath, report) {\n      var fs = require(\"fs\");\n      var path = require(\"path\");\n      var mkdirp = require(\"mkdirp\");\n      mkdirp.sync(path.dirname(reportPath)); //make sure the Reports directory exists\n      fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    }\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 5,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/baseMocha.js",
    "longname": "lib/reports/baseMocha.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/baseMocha.js",
    "importStyle": null,
    "description": "Base methods for mocha reports",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/baseMocha"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Base mocha report functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Base mocha report functions"
    },
    "generator": false
  },
  {
    "__docId__": 6,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/davidCucumber.js",
    "memberof": null,
    "longname": "lib/reports/davidCucumber.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * David cucumber report\n * @exports reports/davidCucumber\n * @returns {Object} David cucumber report functions\n */\nmodule.exports = function davidCucumber() {\n  var david = require(\"david\");\n  var base = require(\"./baseCucumber\")();\n\n  var exports = {\n    /**\n     * Prepare the report header\n     * @returns {Object} the report header\n     */\n    \"prepare\": function prepare() {\n      return base.prepare(\n        \"feature\",\n        \"David dependency analysis\",\n          \"As a developer\\n\" +\n          \"I want to keep my package dependencies up to date\\n\" +\n          \"So that my package is up to date with bug fixes and security patches\");\n    },\n    /**\n     * Write a new test\n     * @param {Object} opts - the david options\n     * @param {String} opts.suite - the test suite name\n     * @param {Object} pkgs - the package dependency analysis returned by david\n     * @param {String} pkg - the package to write test for\n     * @param {Object} rpt - the report object to write or add the test result to\n     */\n    \"write\": function writeTest(opts, pkgs, pkg, rpt) {\n      var result = {\n        \"id\": pkg.replace(/.*[\\\\\\/]/, \"\"),\n        \"keyword\": \"Scenario\",\n        \"name\": opts.suiteName + \" - \" + pkg.replace(/.*[\\\\\\/]/, \"\"),\n        \"line\": 3,\n        \"description\": opts.suiteName + \" - \" + pkg,\n        \"type\": \"scenario\",\n        \"steps\": [\n          {\n            \"result\": {\n              \"duration\": 0,\n              \"status\": \"passed\"\n            },\n            \"name\": \"the package dependency \" + pkg,\n            \"keyword\": \"Given \",\n            \"line\": 4\n          },\n          {\n            \"result\": {\n              \"duration\": 0,\n              \"status\": \"passed\"\n            },\n            \"name\": \"analysed using David\",\n            \"keyword\": \"When \",\n            \"line\": 5\n          },\n          {\n            \"result\": {\n              \"duration\": 0,\n              \"status\": \"passed\"\n            },\n            \"name\": \"the dependency should be current\",\n            \"keyword\": \"Then \",\n            \"line\": 6\n          }\n        ]\n      };\n      //need to perform (pkgs[pkg].required !==  \"^\" + pkgs[pkg].stable) due to issue found with through2\n      if (david.isUpdated(pkgs[pkg]) && !pkgs[pkg].warn && pkgs[pkg].required !== \"^\" + pkgs[pkg].stable) {\n        result.steps[2].result.status = \"failed\";\n        /*eslint camelcase:0*/\n        result.steps[2].result.error_message =\n          pkg + \" | Required: \" + pkgs[pkg].required + \" Stable: \" + pkgs[pkg].stable;\n      }\n      rpt[0].elements.push(result);\n      //no return - rpt past by reference\n    },\n    \"writeToFileSync\": base.writeToFileSync\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 7,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/davidCucumber.js",
    "longname": "lib/reports/davidCucumber.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/davidCucumber.js",
    "importStyle": null,
    "description": "David cucumber report",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/davidCucumber"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} David cucumber report functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "David cucumber report functions"
    },
    "generator": false
  },
  {
    "__docId__": 8,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/davidMocha.js",
    "memberof": null,
    "longname": "lib/reports/davidMocha.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * David mocha report\n * @exports reports/davidMocha\n * @returns {Object} David mocha report functions\n */\nmodule.exports = function davidMocha() {\n  var david = require(\"david\");\n  var base = require(\"./baseMocha\")();\n\n  var exports = {\n    /**\n     * Prepare the report header\n     * @param {String} start - start time and date\n     * @param {String} end - end time and date (will be overwritten by write report function)\n     * @returns {Object} the report header\n     */\n    \"prepare\": base.prepare,\n    /**\n     * Write a new test\n     * @param {Object} opts - the david options\n     * @param {String} opts.suite - the test suite name\n     * @param {Object} pkgs - the package dependency analysis returned by david\n     * @param {String} pkg - the package to write test for\n     * @param {Object} rpt - the report object to write or add the test result to\n     */\n    \"write\": function writeTest(opts, pkgs, pkg, rpt) {\n      if (david.isUpdated(pkgs[pkg]) && !pkgs[pkg].warn && pkgs[pkg].required !== \"^\" + pkgs[pkg].stable) {\n        base.write(opts.suite, false, {\n          \"title\": pkg,\n          \"fullTitle\": opts.suite + \": \" + pkg,\n          \"duration\": 0,\n          \"error\": pkg + \" | Required: \" + pkgs[pkg].required + \" Stable: \" + pkgs[pkg].stable\n        }, rpt);\n      } else {\n        base.write(opts.suite, true, {\n          \"title\": pkg,\n          \"fullTitle\": opts.suite + \": \" + pkg,\n          \"duration\": 0\n        }, rpt);\n      }\n      //no return - rpt past by reference\n    },\n    /**\n     * Synchronously write a test report to a file location\n     * @param {String} reportPath - the file path including filename\n     * @param {Object} report - the report object containing report header and results\n     */\n    \"writeToFileSync\": base.writeToFileSync\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 9,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/davidMocha.js",
    "longname": "lib/reports/davidMocha.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/davidMocha.js",
    "importStyle": null,
    "description": "David mocha report",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/davidMocha"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} David mocha report functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "David mocha report functions"
    },
    "generator": false
  },
  {
    "__docId__": 10,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/eslintBunyan.js",
    "memberof": null,
    "longname": "lib/reports/eslintBunyan.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Eslint bunyan report logger.\n * @exports reports/eslintBunyan\n * @param {Array} results - eslint results returned through gulp-eslint\n * @returns {String} empty string\n */\nmodule.exports = function eslintBunyan(results) {\n  var bunyanFormat = require(\"bunyan-format\");\n  var formatOut = bunyanFormat({\"outputMode\": \"short\"});\n  var logger = require(\"bunyan\").createLogger({\"name\": \"CGULP\", \"stream\": formatOut});\n\n  var getMessageType = function getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n      return \"Error\";\n    }\n    return \"Warning\";\n  };\n  var messageFormat = function messageFormat(message) {\n    var output = getMessageType(message);\n    output += message.ruleId ? \" (\" + message.ruleId + \"):\" : \" :\";\n    output += \" [line:\" + (message.line || 0);\n    output += \",col:\" + (message.column || 0);\n    output += \"]\"; // - \" + message.message;\n    return output;\n  };\n\n  results.forEach(function eachResult(result) {\n    var suite = result.filePath.replace(/.*[\\\\\\/]/, \"\");\n    var messages = result.messages;\n    var messageOutput;\n\n    if (messages.length > 0) {\n      messages.forEach(function eachMessage(message) {\n        messageOutput = suite + \": \" + messageFormat(message);\n        if (message.fatal || message.severity === 2) {\n          logger.error(messageOutput);\n        } else {\n          logger.warn(messageOutput);\n        }\n      });\n    }\n  });\n\n  return \"\";\n};\n"
  },
  {
    "__docId__": 11,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/eslintBunyan.js",
    "longname": "lib/reports/eslintBunyan.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/eslintBunyan.js",
    "importStyle": null,
    "description": "Eslint bunyan report logger.",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/eslintBunyan"
      },
      {
        "tagName": "@returns",
        "tagValue": "{String} empty string"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "results",
        "description": "eslint results returned through gulp-eslint"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "empty string"
    },
    "generator": false
  },
  {
    "__docId__": 12,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/eslintCucumber.js",
    "memberof": null,
    "longname": "lib/reports/eslintCucumber.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Eslint cucumber report\n * @exports reports/eslintCucumber\n * @param {Array} results - eslint results returned through gulp-eslint\n * @returns {Object} Eslint cucumber report formatter\n */\nmodule.exports = function eslintCucumber(results) {\n  var base = require(\"./baseCucumber\")();\n  var report = base.prepare(\n    \"feature\",\n    \"Eslint code analysis\",\n      \"As a developer\\n\" +\n      \"I want to ensure Eslint code analysis standards are met\\n\" +\n      \"So that my code is conformant with technical standards designed to ensure consistency and readability\");\n  var getMessageType = function getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n      return \"Error\";\n    }\n    return \"Warning\";\n  };\n  var messageFormat = function messageFormat(suite, message) {\n    var output = getMessageType(message);\n    output += message.ruleId ? \" (\" + message.ruleId + \"):\" : \" :\";\n    output += \" [line:\" + (message.line || 0);\n    output += \",col:\" + (message.column || 0);\n    output += \"] - \" + message.message;\n    output += \"\\n\";\n    return output;\n  };\n\n  results.forEach(function eachResult(result) {\n    var suite = result.filePath;\n    var messages = result.messages;\n    var messageOutput = \"\";\n    var testPass = true;\n\n    var scenario = {\n      \"id\": suite.replace(/.*[\\\\\\/]/, \"\"),\n      \"keyword\": \"Scenario\",\n      \"name\": suite.replace(/.*[\\\\\\/]/, \"\"),\n      \"line\": 3,\n      \"description\": suite,\n      \"type\": \"scenario\",\n      \"steps\": [\n        {\n          \"result\": {\n            \"duration\": 0,\n            \"status\": \"passed\"\n          },\n          \"name\": \"a Javascript file and the repositories default ESLint configuration file\",\n          \"keyword\": \"Given \",\n          \"line\": 4\n        },\n        {\n          \"result\": {\n            \"duration\": 0,\n            \"status\": \"passed\"\n          },\n          \"name\": \"analysed using ESLint\",\n          \"keyword\": \"When \",\n          \"line\": 5\n        },\n        {\n          \"result\": {\n            \"duration\": 0,\n            \"status\": \"passed\"\n          },\n          \"name\": \"the file should meet the defined coding standards\",\n          \"keyword\": \"Then \",\n          \"line\": 6\n        }\n      ]\n    };\n\n    if (messages.length > 0) {\n      messages.forEach(function eachMessage(message) {\n        if (message.fatal || message.severity === 2) {\n          testPass = false;\n        }\n        messageOutput += messageFormat(suite, message);\n      });\n    }\n\n    if (!testPass) {\n      scenario.steps[2].result.status = \"failed\";\n      /*eslint camelcase:0*/\n      scenario.steps[2].result.error_message = messageOutput;\n    }\n    report[0].elements.push(scenario);\n  });\n\n  return JSON.stringify(report, null, 2);\n};\n"
  },
  {
    "__docId__": 13,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/eslintCucumber.js",
    "longname": "lib/reports/eslintCucumber.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/eslintCucumber.js",
    "importStyle": null,
    "description": "Eslint cucumber report",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/eslintCucumber"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Eslint cucumber report formatter"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "results",
        "description": "eslint results returned through gulp-eslint"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Eslint cucumber report formatter"
    },
    "generator": false
  },
  {
    "__docId__": 14,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/eslintMocha.js",
    "memberof": null,
    "longname": "lib/reports/eslintMocha.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Eslint mocha report\n * @exports reports/eslintMocha\n * @param {Array} results - eslint results returned through gulp-eslint\n * @returns {Object} Eslint mocha report formatter\n */\nmodule.exports = function eslintMocha(results) {\n  var base = require(\"./baseMocha\")();\n  var report = base.prepare();\n  var getMessageType = function getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n      return \"Error\";\n    }\n    return \"Warning\";\n  };\n  var messageFormat = function messageFormat(message) {\n    var output = getMessageType(message);\n    output += message.ruleId ? \" (\" + message.ruleId + \"):\" : \" :\";\n    output += \" [line:\" + (message.line || 0);\n    output += \",col:\" + (message.column || 0);\n    output += \"] - \" + message.message;\n    output += \"\\n\";\n    return output;\n  };\n\n  results.forEach(function eachResult(result) {\n    var suite = result.filePath;\n    var messages = result.messages;\n    var messageOutput = suite.replace(/.*[\\\\\\/]/, \"\") + \"\\n\";\n    var mochaOutput = {\n      \"title\": suite.replace(/.*[\\\\\\/]/, \"\"),\n      \"fullTitle\": suite,\n      \"duration\": 0\n    };\n    var testPass = true;\n\n    if (messages.length > 0) {\n      messages.forEach(function eachMessage(message) {\n        if (message.fatal || message.severity === 2) {\n          testPass = false;\n        }\n        messageOutput += messageFormat(message);\n      });\n      mochaOutput.error = messageOutput;\n    }\n    base.write(suite, testPass, mochaOutput, report);\n  });\n\n  return JSON.stringify(report, null, 2);\n};\n"
  },
  {
    "__docId__": 15,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/eslintMocha.js",
    "longname": "lib/reports/eslintMocha.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/eslintMocha.js",
    "importStyle": null,
    "description": "Eslint mocha report",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/eslintMocha"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Eslint mocha report formatter"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "results",
        "description": "eslint results returned through gulp-eslint"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Eslint mocha report formatter"
    },
    "generator": false
  },
  {
    "__docId__": 16,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/genericCucumber.js",
    "memberof": null,
    "longname": "lib/reports/genericCucumber.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Generic cucumber report\n * @exports reports/genericCucumber\n * @returns {Object} Generic cucumber report functions\n */\nmodule.exports = function davidCucumber() {\n  var base = require(\"./baseCucumber\")();\n\n  var exports = {\n    /**\n     * Prepare the report header\n     * @param {String} type - the test report type (e.g. feature, bug)\n     * @param {String} name - the test report name\n     * @param {String} description - the test report description\n     * @returns {Object} the report header\n     */\n    \"prepare\": base.prepare,\n    /**\n     * Write a new test\n     * @param {String} suiteName - the test suite name\n     * @param {String} testName - the test name\n     * @param {Array} errorMessages - the error messages if the test failed\n     * @param {String} givenDesc - the given step part description\n     * @param {String} whenDesc - the when step part description\n     * @param {String} thenDesc - the then step part description\n     * @param {Object} rpt - the report object to write or add the test result to\n     */\n    \"write\": function writeTest(suiteName, testName, errorMessages, givenDesc, whenDesc, thenDesc, rpt) {\n      var result = {\n        \"id\": testName.replace(/.*[\\\\\\/]/, \"\"),\n        \"keyword\": \"Scenario\",\n        \"name\": testName,\n        \"line\": 3,\n        \"description\": suiteName + \": \" + testName,\n        \"type\": \"scenario\",\n        \"steps\": [\n          {\n            \"result\": {\n              \"duration\": 0,\n              \"status\": \"passed\"\n            },\n            \"name\": givenDesc,\n            \"keyword\": \"Given \",\n            \"line\": 4\n          },\n          {\n            \"result\": {\n              \"duration\": 0,\n              \"status\": \"passed\"\n            },\n            \"name\": whenDesc,\n            \"keyword\": \"When \",\n            \"line\": 5\n          },\n          {\n            \"result\": {\n              \"duration\": 0,\n              \"status\": \"passed\"\n            },\n            \"name\": thenDesc,\n            \"keyword\": \"Then \",\n            \"line\": 6\n          }\n        ]\n      };\n      if (errorMessages.length > 0) {\n        result.steps[2].result.status = \"failed\";\n        /*eslint camelcase:0*/\n        result.steps[2].result.error_message = errorMessages.join(\"\\n\");\n      }\n      rpt[0].elements.push(result);\n      //no return - rpt past by reference\n    },\n    \"writeToFileSync\": base.writeToFileSync\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 17,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/genericCucumber.js",
    "longname": "lib/reports/genericCucumber.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/genericCucumber.js",
    "importStyle": null,
    "description": "Generic cucumber report",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/genericCucumber"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Generic cucumber report functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Generic cucumber report functions"
    },
    "generator": false
  },
  {
    "__docId__": 18,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/genericMocha.js",
    "memberof": null,
    "longname": "lib/reports/genericMocha.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Generic mocha report\n * @exports reports/genericMocha\n * @returns {Object} Generic mocha report functions\n */\nmodule.exports = function genericMocha() {\n  var base = require(\"./baseMocha\")();\n\n  var exports = {\n    /**\n     * Prepare the report header\n     * @returns {Object} the report header\n     */\n    \"prepare\": function prepare() {\n      return base.prepare();\n    },\n    /**\n     * Write a new test\n     * @param {String} suiteName - the test suite name\n     * @param {String} testName - the test name\n     * @param {Array} errorMessages - the error messages if the test failed\n     * @param {Object} rpt - the report object to write or add the test result to\n     */\n    \"write\": function writeTest(suiteName, testName, errorMessages, rpt) {\n      if (errorMessages.length > 0) {\n        base.write(suiteName, false, {\n          \"title\": testName,\n          \"fullTitle\": suiteName + \": \" + testName,\n          \"duration\": 0,\n          \"error\": errorMessages.join(\"\\n\")\n        }, rpt);\n      } else {\n        base.write(suiteName, true, {\n          \"title\": testName,\n          \"fullTitle\": suiteName + \": \" + testName,\n          \"duration\": 0\n        }, rpt);\n      }\n      //no return - rpt past by reference\n    },\n    /**\n     * Synchronously write a test report to a file location\n     * @param {String} reportPath - the file path including filename\n     * @param {Object} report - the report object containing report header and results\n     */\n    \"writeToFileSync\": base.writeToFileSync\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 19,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/genericMocha.js",
    "longname": "lib/reports/genericMocha.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/genericMocha.js",
    "importStyle": null,
    "description": "Generic mocha report",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/genericMocha"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Generic mocha report functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Generic mocha report functions"
    },
    "generator": false
  },
  {
    "__docId__": 20,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/postBuildCucumber.js",
    "memberof": null,
    "longname": "lib/reports/postBuildCucumber.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Post build cucumber report\n * @exports reports/postBuildCucumber\n * @param {String} suiteName - the test suite name\n * @param {Array} results - post build results returned as an array of object test results.\n * The test result object contains two properties `testName` and `errMessage`\n * e.g. `{testName: \"test description\", errMessage: \"error message\"}`\n * @param {String} [reportPath] - the file path including filename\n * @returns {Object} Post build cucumber report in JSON\n */\nmodule.exports = function postBuildCucumber(suiteName, results, reportPath) {\n  var base = require(\"./genericCucumber\")();\n  var report = base.prepare(\n    \"feature\",\n    \"Post build verification test\",\n    \"As a developer\\n\" +\n    \"I can run post build verification tests\\n\" +\n    \"So that I can catch incomplete builds which failed to complete tests and packaging tasks\");\n\n  results.forEach(function eachResult(result) {\n    base.write(\n      suiteName,\n      result.testName,\n      result.errorMessages,\n      /*Given */\"the build task has completed\",\n      /*When */\"performing the post build verification test\",\n      /*Then */\"the test should pass\",\n      report);\n  });\n\n  if (reportPath){\n    base.writeToFileSync(reportPath, report);\n  }\n  return report;\n};\n"
  },
  {
    "__docId__": 21,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/postBuildCucumber.js",
    "longname": "lib/reports/postBuildCucumber.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/postBuildCucumber.js",
    "importStyle": null,
    "description": "Post build cucumber report",
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/postBuildCucumber"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Post build cucumber report in JSON"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "suiteName",
        "description": "the test suite name"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "results",
        "description": "post build results returned as an array of object test results.\nThe test result object contains two properties `testName` and `errMessage`\ne.g. `{testName: \"test description\", errMessage: \"error message\"}`"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "reportPath",
        "description": "the file path including filename"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Post build cucumber report in JSON"
    },
    "generator": false
  },
  {
    "__docId__": 22,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/reports/postBuildMocha.js",
    "memberof": null,
    "longname": "lib/reports/postBuildMocha.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Post build mocha report\n * @exports reports/postBuildMocha\n * @param {String} suiteName - the test suite name\n * @param {Array} results - post build results returned as an array of object test results.\n * The test result object contains two properties `testName` and `errMessage`\n * e.g. `{testName: \"test description\", errMessage: \"error message\"}`\n * @param {String} [reportPath] - the file path including filename\n * @returns {Object} Post build mocha report in JSON\n */\nmodule.exports = function postBuildMocha(suiteName, results, reportPath) {\n  var base = require(\"./genericMocha\")();\n  var report = base.prepare();\n\n  results.forEach(function eachResult(result) {\n    base.write(\n      suiteName,\n      result.testName,\n      result.errorMessages,\n      report);\n  });\n\n  if (reportPath){\n    base.writeToFileSync(reportPath, report);\n  }\n  return report;\n};\n"
  },
  {
    "__docId__": 23,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/reports/postBuildMocha.js",
    "longname": "lib/reports/postBuildMocha.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/reports/postBuildMocha.js",
    "importStyle": null,
    "description": "Post build mocha report",
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "reports/postBuildMocha"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Post build mocha report in JSON"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "suiteName",
        "description": "the test suite name"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "results",
        "description": "post build results returned as an array of object test results.\nThe test result object contains two properties `testName` and `errMessage`\ne.g. `{testName: \"test description\", errMessage: \"error message\"}`"
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "reportPath",
        "description": "the file path including filename"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Post build mocha report in JSON"
    },
    "generator": false
  },
  {
    "__docId__": 24,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/utils/autoUpdate.js",
    "memberof": null,
    "longname": "lib/utils/autoUpdate.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n\n/**\n * Auto update build utilities.\n * @exports utils/autoUpdate\n * @param {bunyan} logger - A logger matching the bunyan API\n * @returns {Object} Auto update build utility functions\n */\nmodule.exports = function autoUpdateUtils(logger) {\n  var vasync = require(\"vasync\");\n  var _ = require(\"underscore\");\n  var jiraUtils = require(\"./jira\")(logger);\n  var bambooUtils = require(\"./bamboo\")(logger);\n  var execUtils = require(\"../../bin/exec\")(logger);\n  var reportUtils = require(\"./reports\")();\n  var chalk = require(\"chalk\");\n\n  var rename = require(\"gulp-rename\");\n  var path = require(\"path\");\n  var GulpDustCompileRender = require(\"gulp-dust-compile-render\");\n  var AsyncPipe = require(\"gulp-async-func-runner\");\n\n\n  var exports = {\n    /**\n     * Run the update task on all projects matching specified criteria and generate output reports.\n     * @param {Object} opts - options\n     * @param {String} [opts.repositoryUrl] - the url to the repository containing packages for checking and update\n     * @param {String} [opts.BUILD_DIR=\"Build\"] - download the repository to this temporary build directory\n     * @param {String} [opts.category=\"\"] - all projects with this JIRA project category\n     * are to be included on the update\n     * @param {Array} [opts.include=[]] - array of short repository paths to be included in the update\n     * @param {Array} [opts.exclude=[]] - array of short repository paths to be excluded in the update\n     * @param {Boolean} [opts.updateCheck=false] - flag whether to run tasks to auto-check\n     * whether an update is required\n     * @param {String} [opts.updateCheckTask=\"all\"] - gulp task used to auto-check whether an update is required\n     * @param {Boolean} [opts.updateSource=false] - flag whether to run tasks to auto-update the source\n     * and then commit\n     * @param {String} [opts.updateSourceTask=\"all\"] - gulp task used to auto-update the source\n     * @param {String} [opts.updateSourceSummary=\"\"] - the summary description for the issue created to track\n     * source update progress\n     * @param {String} [opts.updateSourceType=\"Non-functional\"] - the issue type for the issue created to track\n     * source update progress\n     * @param {String} [opts.bambooBuildTask=\"all\"] - gulp task used for Bamboo build\n     * @param {String} [opts.bambooPostBuildTask=\"post_build\"] - gulp task used for Bamboo post build\n     * @param {Function} gulp - gulp object used to wrap the `autoUpdate` function in a gulp task\n     * @param {Object} context - context object passed to gulp tasks used to obtain context.cwd - current working\n     * directory\n     * @returns {through2} stream\n     */\n    \"run\": function run(opts, gulp, context) {\n      var self = this;\n      var results = {};\n      var directories = context.package.directories || {};\n      var reportPath = path.join(context.cwd, directories.reports || \"reports\");\n      return gulp.src(path.join(__dirname, \"../../tasks/templates/auto-update-report.dust\"))\n        .pipe(new AsyncPipe({\n            \"oneTimeRun\": true,\n            \"passThrough\": true\n          },\n          function runAutoUpdate(op, chunk, cb) {\n            self.autoUpdate(opts, cb);\n          },\n          function writeReports(error, autoUpdateWorkflows) {\n            //save results for reports\n            var reportWriter = require(\"../reports/autoUpdateMocha\")();\n            var report = reportWriter.prepare();\n\n            logger.debug(JSON.stringify(autoUpdateWorkflows, null, 2));\n\n            _.each(autoUpdateWorkflows, function eachAutoUpdateWorkflow(workflowHistory) {\n              //ensure properties exist\n              _.defaults(workflowHistory, {\n                \"bambooTest\": {\n                  \"buildState\": null\n                },\n                \"releasedVersion\": {\n                  \"name\": null,\n                  \"issuesUnresolvedCount\": null\n                },\n                \"bambooRelease\": {\n                  \"buildNumber\": null,\n                  \"buildState\": null\n                }\n              });\n              reportWriter.write(workflowHistory, report);\n            });\n            reportWriter.writeToFileSync(reportPath + \"/autoUpdate-mocha-tests.json\", report);\n            results.projects = autoUpdateWorkflows;\n          }))\n        .pipe(new GulpDustCompileRender(results))\n        .pipe(rename(function renameExtension(renamePath) {\n            renamePath.extname = \".html\";\n        }))\n        .pipe(gulp.dest(reportPath));\n    },\n\n    /**\n     * Execute update task on all projects matching specified criteria.\n     * @param {Object} opts - options\n     * @param {String} [opts.repositoryUrl] - the url to the repository containing packages for checking and update\n     * @param {String} [opts.BUILD_DIR=\"Build\"] - download the repository to this temporary build directory\n     * @param {String} [opts.category=\"\"] - all projects with this JIRA project category are\n     * to be included on the update\n     * @param {Array} [opts.include=[]] - array of short repository paths to be included in the update\n     * @param {Array} [opts.exclude=[]] - array of short repository paths to be excluded in the update\n     * @param {Boolean} [opts.updateCheck=false] - flag whether to run tasks to auto-check whether\n     * an update is required\n     * @param {String} [opts.updateCheckTask=\"all\"] - gulp task used to auto-check whether an update is required\n     * @param {Boolean} [opts.updateSource=false] - flag whether to run tasks to auto-update the source\n     * and then commit\n     * @param {String} [opts.updateSourceTask=\"all\"] - gulp task used to auto-update the source\n     * @param {String} [opts.updateSourceSummary=\"\"] - the summary description for the issue created to track\n     * source update progress\n     * @param {String} [opts.updateSourceType=\"Non-functional\"] - the issue type for the issue created to track\n     * source update progress\n     * @param {String} [opts.bambooBuildTask=\"all\"] - gulp task used for Bamboo build\n     * @param {String} [opts.bambooPostBuildTask=\"post_build\"] - gulp task used for Bamboo post build\n     * @param {Function} cb - callback function with signature: function(err, data)\n     * @example\n     {>example-autoUpdate/}\n     */\n    \"autoUpdate\": function autoUpdate(opts, cb) {\n      var self = this;\n      var updateProjectAsyncFuncArray = [];\n\n      logger.info(chalk.cyan(\"Starting auto update task\"));\n      opts = opts || {};\n      _.defaults(opts, {\n        \"BUILD_DIR\": \"Build\",\n        \"category\": \"\",\n        \"include\": [],\n        \"exclude\": [],\n        \"updateCheck\": false,\n        \"updateCheckTask\": \"all\",\n        \"updateSource\": false,\n        \"updateSourceTask\": \"all\",\n        \"updateSourceSummary\": \"\",\n        \"updateSourceType\": \"Non-functional\",\n        \"bambooBuildTask\": \"all\",\n        \"bambooPostBuildTask\": \"post_build\"\n      });\n\n      //get start list of projects to check/update using project category\n      jiraUtils.getProjects(function getProjectsCallback(error, data) {\n        var i;\n        var updateProjectFunc = function updateProjectFunc(repositoryPath, project) {\n          var buildPlanName = repositoryPath.split(\"/\").join(\" - \").toLowerCase();\n          //need to convert the avatarUrls properties to start with a character\n          //so that dust template can use them.\n          project.avatarUrls.xsmall = project.avatarUrls[\"16x16\"];\n          project.avatarUrls.small = project.avatarUrls[\"24x24\"];\n          project.avatarUrls.medium = project.avatarUrls[\"32x32\"];\n          project.avatarUrls.large = project.avatarUrls[\"48x48\"];\n          project.shortName = project.name.split(\"/\")[1];\n          return function updateProject(arg, callback) {\n            _.extend(opts, {\n              \"buildPlanName\": buildPlanName,\n              \"repositoryPath\": repositoryPath,\n              \"project\": project\n            });\n            self.updateProject(opts, function updateProjectCallback(err, workflowHistory) {\n              callback(err, workflowHistory);\n            });\n          };\n        };\n\n        if (!error) {\n          for (i = 0; i < data.length; i = i + 1) {\n            if ((data[i].projectCategory && data[i].projectCategory.name === opts.category ||\n              _.contains(opts.include, data[i].key)) && !_.contains(opts.exclude, data[i].key)) {\n              updateProjectAsyncFuncArray.push(updateProjectFunc(data[i].name, data[i]));\n            }\n          }\n          vasync.pipeline({\n            \"funcs\": updateProjectAsyncFuncArray\n          }, function updateProjectAsyncFuncArrayCallback(err, results) {\n            logger.info(chalk.cyan(\"Finished auto update task\"));\n            cb(err, results.successes);\n          });\n        } else {\n          cb(error);\n        }\n      });\n    },\n\n    /**\n     * Execute update task on a project.\n     * @param {Object} opts - options\n     * @param {String} opts.BUILD_DIR - download the repository to this temporary build directory\n     * @param {String} opts.repositoryUrl - the url to the repository containing packages for checking and update\n     * @param {String} opts.repositoryPath - short repository path of project to be processed\n     * @param {Object} opts.project - the JIRA project metadata\n     * @param {Boolean} opts.updateCheck - flag whether to run tasks to auto-check whether an update is required\n     * @param {String} opts.updateCheckTask - gulp task used to auto-check whether an update is required\n     * @param {Boolean} opts.updateSource - flag whether to run tasks to auto-update the source and then commit\n     * @param {String} opts.updateSourceTask - gulp task used to auto-update the source\n     * @param {Boolean} opts.releaseVersion - flag whether to release the patch version for an update\n     * @param {Function} cb - callback function with signature: function(err, data)\n     */\n    \"updateProject\": function updateProject(opts, cb) {\n      var self = this;\n      var workflowHistory = {\n        \"project\": opts.project,\n        \"clearFolder\": null,\n        \"updateCheck\": null,\n        \"updateCheckText\": null,\n        \"updateSourceJiraIssue\": null,\n        \"bambooTest\": null,\n        \"bambooRelease\": null,\n        \"transitionedIssue\": null,\n        \"releasedVersion\": null,\n        \"clearedBuildFolder\": null\n      };\n\n      logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Starting auto update\"));\n\n      vasync.waterfall([\n        function preAutoUpdate(callback) {\n          logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Pre auto update\"));\n          logger.debug(\"CPM clear folder: \" + opts.BUILD_DIR);\n          execUtils.clearFolder(opts.BUILD_DIR, function clearFolderCallback(err) {\n            workflowHistory.clearFolder = \"Cleared folder \" + opts.BUILD_DIR;\n            callback(err);\n          });\n        },\n        function updateCheck(callback) {\n          if (opts.updateCheck) {\n            logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Update check\"));\n            self.updateCheck(opts, function updateCheckCallback(err, reportFailures) {\n              if (!err) {\n                workflowHistory.updateCheck = \"\" + (reportFailures.length > 0);\n                callback(null, reportFailures.length > 0);\n              } else {\n                callback(err, false);//set to false to stop workflow\n              }\n            });\n          } else {\n            callback(null, true); //updateRequired=true if no updateCheck required\n          }\n        },\n        function updateSource(updateRequired, callback) {\n          if (updateRequired && opts.updateSource) { //updateRequired will be true if no check performed\n            logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Update source\"));\n            self.updateSource(opts, function updateSourceCallback(err, issue) {\n              //JIRA issue created to record update task\n              workflowHistory.updateSourceJiraIssue = issue;\n              callback(err, updateRequired && err === null, issue);\n            });\n          } else {\n            //buildRequired=true && updateRequired if no updateSource required\n            callback(null, updateRequired, null);\n          }\n        },\n        function testBuild(buildRequired, issue, callback) {\n          if (buildRequired && issue !== null) {\n            logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Test build\"));\n            logger.info(\"Bamboo trigger build: \" + opts.buildPlanName);\n            bambooUtils.triggerBamboo(opts.buildPlanName, {\n              \"gulp_task\": opts.bambooBuildTask,\n              \"gulp_post_task\": opts.bambooPostBuildTask\n            }, function triggerBambooCallback(err, buildResult) {\n              workflowHistory.bambooTest = buildResult;\n              callback(err, buildResult, issue);\n            });\n          } else {\n            callback(null, null, issue); //buildRequired=false\n          }\n        },\n        function releaseBuild(buildResult, issue, callback) {\n          if (opts.releaseVersion && buildResult && buildResult.successful) {\n            logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Release build\"));\n            self.releaseBuild(issue, workflowHistory, opts, function releaseBuildCallback(err) {\n              callback(err);\n            });\n          } else {\n            callback(null);\n          }\n        },\n        function postAutoUpdate(callback) {\n          logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Post auto update\"));\n          logger.debug(\"CPM clear folder: \" + opts.BUILD_DIR);\n          execUtils.clearFolder(opts.BUILD_DIR, function clearFolderCallback(err) {\n            workflowHistory.clearedBuildFolder = true;\n            callback(err);\n          });\n        }\n      ], function finishAutoUpdate(err) {\n        logger.info(opts.project.key + \" \" + opts.project.name + \": \" + chalk.magenta(\"Finished auto update\"));\n        cb(err, workflowHistory);\n      });\n    },\n\n    /**\n     * Check whether an update is required by cloning the master branch of the project to a directory and\n     * running a provided gulp task. The provided gulp task is expected to generate test reports.\n     * The test reports are checked for any failures. If one or more failures found then this function\n     * will return false in the callback data. Otherwise this function will return true in the callback data.\n     * @param {Object} opts - options\n     * @param {String} opts.BUILD_DIR - download the repository to this temporary build directory\n     * @param {String} opts.repositoryUrl - the url to the repository containing packages for checking and update\n     * @param {String} opts.repositoryPath - short repository path of project to be cloned to the BUILD_DIR\n     * @param {String} opts.updateCheckTask - gulp task used to perform the update check\n     * @param {Function} cb - callback function with signature: function(err, data)\n     */\n    \"updateCheck\": function updateCheck(opts, cb) {\n      vasync.waterfall([\n        function cloneProjectFromGit(callback) {\n          execUtils.cloneFromGit(opts.repositoryUrl + opts.repositoryPath, opts.BUILD_DIR, null,\n            function cloneFromGitCallback(err, stdout) {\n              callback(err, stdout);\n            });\n        },\n        function runUpdateCheckTask(data, callback) {\n          execUtils.runGulpTask(opts.updateCheckTask, process.cwd() + \"/\" + opts.BUILD_DIR,\n            function runGulpTaskCallback(err, cbData) {\n              callback(err, cbData);\n            });\n        },\n        function getReportFailures(data, callback) {\n          callback(null, reportUtils.getReportFailures(opts.BUILD_DIR + \"/Reports\"));\n        }\n      ], cb);\n    },\n\n    /**\n     * Update the source of a project by cloning the master branch of the project and running the provided\n     * gulp task. A JIRA issue is created to track the progress of the update. The issue is transitioned to\n     * In Progress and QA. Once the update is complete the source is committed back to the repository triggering\n     * a Bamboo build on the master branch.\n     * @param {Object} opts - options\n     * @param {String} opts.BUILD_DIR - download the repository to this temporary build directory\n     * @param {String} opts.repositoryUrl - the url to the repository containing packages for checking and update\n     * @param {String} opts.repositoryPath - short repository path of project to be processed\n     * @param {String} opts.updateSourceTask - gulp task used to auto-update the source\n     * @param {String} opts.updateSourceSummary - the summary description for the issue created to track source\n     * update progress\n     * @param {String} opts.updateSourceType - the issue type for the issue created to track source update progress\n     * @param {Function} cb - callback function with signature: function(err, issue)\n     */\n    \"updateSource\": function updateSource(opts, cb) {\n      vasync.waterfall([\n        function getNextUnreleasedPatchVersion(callback) {\n          logger.info(\"JIRA get next unreleased path version for project: \" + opts.project.key);\n          jiraUtils.getNextUnreleasedPatchVersion(opts.project.key,\n            function getNextUnreleasedPatchVersionCallback(err, version) {\n              callback(err, version);\n            });\n        },\n        function createNewIssue(version, callback) {\n          logger.info(\"JIRA create issue with version: v\" + version);\n          jiraUtils.createIssue({\n              \"key\": opts.project.key,\n              \"summary\": opts.updateSourceSummary,\n              \"issueType\": opts.updateSourceType,\n              \"version\": version\n            },\n            function createIssueCallback(err, issue) {\n              issue = issue || {}; //only id, key and selfURL properties returned\n              issue.version = version;\n              callback(err, issue);\n            });\n        },\n        function transitionIssueToInProgress(issue, callback) {\n          logger.info(\"JIRA transition issue to in progress: \" + issue.key);\n          jiraUtils.transitionIssue(issue.key, \"11\", function transitionIssueCallback(err) {\n            callback(err, issue);\n          });\n        },\n        function cloneFromGit(issue, callback) {\n          var clone;\n          if (!opts.updateCheck) {\n            clone = opts.repositoryUrl + opts.repositoryPath;\n            logger.info(\"GIT clone: \" + clone);\n            execUtils.cloneFromGit(clone, opts.BUILD_DIR, null, function cloneFromGitCallback(err) {\n              callback(err, issue);\n            });\n          } else {\n            callback(null, issue);\n          }\n        },\n        function runUpdateSourceTask(issue, callback) {\n          logger.info(\"Gulp task: \" + opts.updateSourceTask);\n          execUtils.runGulpTask(opts.updateSourceTask, process.cwd() + \"/\" + opts.BUILD_DIR,\n            function runGulpTaskCallback(err) {\n              callback(err, issue);\n            });\n        },\n        function commitChanges(issue, callback) {\n          var commit = issue.key + \" [Auto-update] \" + opts.updateSourceSummary;\n          logger.info(\"GIT commit: \" + commit);\n          execUtils.commitGit(commit, process.cwd() + \"/\" + opts.BUILD_DIR, function commitGitCallback(err) {\n            callback(err, issue);\n          });\n        },\n        function transitionIssueToQA(issue, callback) {\n          logger.info(\"JIRA transition issue to QA: \" + issue.key);\n          jiraUtils.transitionIssue(issue.key, \"71\", function transitionIssueCallback(err) {\n            callback(err, issue);\n          });\n        }\n      ], cb);\n    },\n\n\n    /**\n     * Transition issue to \"done\", release a Jira project version, and if there are no unresolved issues\n     * then trigger a release build.\n     * @param {Object} issue - JIRA issue object map containing the properties `key` and `version`\n     * @param {Object} workflowHistory - workflow history object map which will have following properties updated:\n     * workflowHistory.transitionedIssue - true if issues transitioned to Done\n     * workflowHistory.releasedVersion - JIRA version object map where property `released` will be true if there\n     * are no unresolved issues\n     * workflowHistory.bambooBuildResults - Bamboo build results object map\n     * @param {Object} opts - options\n     * @param {String} opts.project - JIRA project object map containing properties `key` and `name`\n     * @param {String} opts.buildPlanName - Bamboo build plan name\n     * @param {Function} cb - callback function with signature: function(err, result)\n     */\n    \"releaseBuild\": function releaseBuild(issue, workflowHistory, opts, cb) {\n      vasync.waterfall([\n        function transitionIssueToDone(callback) {\n          logger.info(\"JIRA transition issue to Done: \" + issue.key);\n          jiraUtils.transitionIssue(issue.key, \"91\", function transitionIssueCallback(err) {\n            workflowHistory.transitionedIssue = true;\n            callback(err);\n          });\n        },\n        function releaseVersion(callback) {\n          logger.info(\"JIRA release version: \" + opts.project.key + \" - v\" + issue.version);\n          jiraUtils.releaseVersion(opts.project.key, issue.version, new global.Date(),\n            function releaseVersionCallback(err, versionObj) {\n              workflowHistory.releasedVersion = versionObj;\n              callback(err, versionObj);\n            });\n        },\n        function triggerReleaseBuild(versionObj, callback) {\n          if (versionObj.released) {\n            logger.info(\"Bamboo trigger release build: \" + opts.buildPlanName + \" - v\" + issue.version);\n            bambooUtils.triggerBamboo(opts.buildPlanName, {\n              \"jira.version\": issue.version,\n              \"jira.projectName\": opts.project.name\n            }, function triggerBambooCallback(err, buildResult) {\n              workflowHistory.bambooRelease = buildResult;\n              callback(err, versionObj, buildResult);\n            });\n          } else {\n            callback(null, versionObj, null);\n          }\n        }\n      ], cb);\n    }\n  };\n\n  return exports;\n};\n"
  },
  {
    "__docId__": 25,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/utils/autoUpdate.js",
    "longname": "lib/utils/autoUpdate.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/utils/autoUpdate.js",
    "importStyle": null,
    "description": "Auto update build utilities.",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "utils/autoUpdate"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Auto update build utility functions"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bunyan"
        ],
        "spread": false,
        "optional": false,
        "name": "logger",
        "description": "A logger matching the bunyan API"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Auto update build utility functions"
    },
    "generator": false
  },
  {
    "__docId__": 26,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/utils/bamboo.js",
    "memberof": null,
    "longname": "lib/utils/bamboo.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\r\n\r\n/**\r\n * Bamboo build utilities\r\n * @exports utils/bamboo\r\n * @param {bunyan} logger - A logger matching the bunyan API\r\n * @returns {Object} Bamboo build utility functions\r\n */\r\nmodule.exports = function bambooUtils(logger) {\r\n  var oauthRest = require(\"oauth-rest-atlassian\").rest;\r\n  var config = require(\"./config\")(\"bamboo\");\r\n  var vasync = require(\"vasync\");\r\n  var _ = require(\"underscore\");\r\n\r\n  var exports = {\r\n    /**\r\n     * Get build plans from Bamboo.\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"getBuildPlans\": function getBuildPlans(cb) {\r\n      //get build plan key\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"plan.json\"\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Queue a build on Bamboo.\r\n     * @param {String} buildPlanKey - key for the build plan to be built\r\n     * @param {Object} variables - an object map containing variables to be past to the bamboo build\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"queueBuild\": function queueBuild(buildPlanKey, variables, cb) {\r\n      //prepare variables\r\n      var variable;\r\n      var variableStr = \"\";\r\n      var cnt = 0;\r\n      for (variable in variables) {\r\n        if (variables.hasOwnProperty(variable)) {\r\n          cnt = cnt + 1;\r\n          if (cnt === 1) {\r\n            variableStr = variableStr + \"?bamboo.variable.\" + variable + \"=\" + variables[variable];\r\n          } else {\r\n            variableStr = variableStr + \"&bamboo.variable.\" + variable + \"=\" + variables[variable];\r\n          }\r\n        }\r\n      }\r\n      //queue build and get build result key\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"queue/\" + buildPlanKey + \".json\" + variableStr,\r\n        \"method\": \"post\",\r\n        \"postData\": {\r\n        }\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Get the queue results of a build project on Bamboo.\r\n     * @param {String} buildPlanKey - key for the build plan to be built\r\n     * @param {Integer} maxResults - maximum size for returned list\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"getResults\": function getResults(buildPlanKey, maxResults, cb) {\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"result/\" + buildPlanKey + \".json?includeAllStates=true&max-results=\" + maxResults\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Get the result of a build queued on Bamboo.\r\n     * @param {String} buildPlanKey - key for the build plan to be built\r\n     * @param {String} buildNumber - the build number to get results from\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"getResult\": function getResult(buildPlanKey, buildNumber, cb) {\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"result/\" + buildPlanKey + \"/\" + buildNumber + \".json\"\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Trigger a build on Bamboo and return the result in the callback.\r\n     * @param {String} buildPlanName - the name of the build plan\r\n     * @param {Object} variables - an object map containing variables to be past to the bamboo build\r\n     * @param {Function} cb - callback function with signature: function(err, result)\r\n     */\r\n    \"triggerBamboo\": function triggerBamboo(buildPlanName, variables, cb) {\r\n      var self = this;\r\n      var latestBuildNumber = null;\r\n\r\n      vasync.waterfall([\r\n        function getBuildPlanKey(callback) {\r\n          self.getBuildPlans(function getBuildPlansCallback(err, data) {\r\n            var buildPlan = _.find(data.plans.plan, function matchPlan(plan) {\r\n              return plan.name.toLowerCase() === buildPlanName;\r\n            });\r\n            callback(err, buildPlan.key);\r\n          });\r\n        },\r\n        function getLastBuildResultKey(buildPlanKey, callback) {\r\n          self.getResults(\r\n            buildPlanKey,\r\n            1,\r\n            function getResultsCallback(err, data) {\r\n              latestBuildNumber = data.results.result[0].buildNumber;\r\n              callback(err, buildPlanKey);\r\n            });\r\n        },\r\n        function queueBuildAndGetResultKey(buildPlanKey, callback) {\r\n          self.queueBuild(\r\n            buildPlanKey,\r\n            variables,\r\n            function queueBuildCallback(err, buildResult) {\r\n              if (err) {\r\n                logger.error(err);\r\n                callback(null, buildPlanKey, buildResult);\r\n              } else {\r\n                callback(err, buildPlanKey, buildResult);\r\n              }\r\n            });\r\n        },\r\n        function getLatestQueuedBuild(buildPlanKey, buildResult, callback) {\r\n          if (!(buildResult && buildResult.buildNumber)) {\r\n            logger.warn(\"Queue build did not return build result. Attempting to get new build result.\");\r\n            self.getResults(\r\n              buildPlanKey,\r\n              1,\r\n              function getResultsCallback(err, data) {\r\n                buildResult = data.results.result[0];\r\n                if (latestBuildNumber === buildResult.buildNumber) {\r\n                  logger.error(\"Queue build failed to queue a new build. \" +\r\n                    \"Last build before trigger: \" + latestBuildNumber + \". \" +\r\n                    \"Current build: \" + buildResult.buildNumber);\r\n                } else {\r\n                  logger.info(\"Queue build returned build result: \" + buildResult.buildNumber);\r\n                }\r\n                callback(err, buildPlanKey, buildResult);\r\n              });\r\n          } else {\r\n            logger.info(\"Queue build returned build result: \" + buildResult.buildNumber);\r\n            callback(null, buildPlanKey, buildResult);\r\n          }\r\n        },\r\n        function waitForBuildCompletion(buildPlanKey, buildResult, callback) {\r\n          var finished = false;\r\n          var result = {};\r\n\r\n          //wait for result\r\n          var whilst = function whilst(test, iterator, callback2) {\r\n            if (test()) {\r\n              iterator(function iteratorCallback(err) {\r\n                if (err) {\r\n                  return callback2(err);\r\n                }\r\n                whilst(test, iterator, callback2);\r\n              });\r\n            } else {\r\n              callback2();\r\n            }\r\n          };\r\n\r\n          whilst(\r\n            function buildComplete() {\r\n              return !finished;\r\n            },\r\n            function waitAndCheck(callback2) {\r\n              setTimeout(function timeoutCallback() {\r\n                self.getResult(\r\n                  buildPlanKey,\r\n                  buildResult.buildNumber,\r\n                  function getResultCallback(err, data) {\r\n                    result = data;\r\n                    finished = data.finished;\r\n                    callback2(err);\r\n                  });\r\n              }, 5000);\r\n            },\r\n            function buildCompletedCallback(err) {\r\n              callback(err, result);\r\n            });\r\n        }\r\n      ], cb);\r\n    }\r\n  };\r\n\r\n  return exports;\r\n};\r\n"
  },
  {
    "__docId__": 27,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/utils/bamboo.js",
    "longname": "lib/utils/bamboo.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/utils/bamboo.js",
    "importStyle": null,
    "description": "Bamboo build utilities",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "utils/bamboo"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Bamboo build utility functions"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bunyan"
        ],
        "spread": false,
        "optional": false,
        "name": "logger",
        "description": "A logger matching the bunyan API"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Bamboo build utility functions"
    },
    "generator": false
  },
  {
    "__docId__": 28,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/utils/config.js",
    "memberof": null,
    "longname": "lib/utils/config.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\n/**\n * Application configuration utility\n * @exports utils/config\n * @param {String} application - application\n * @returns {Object} configuration for application\n */\nmodule.exports = function configUtils(application) {\n  var path = require(\"path\");\n  var fs = require(\"fs\");\n  var config = {};\n  var configPath = path.resolve(__dirname, \"../..\") + \"/config.json\";\n  var defaultConfigPath = path.resolve(__dirname, \"../..\") + \"/defaultConfig.json\";\n  //check if the oauth config file exists\n  if (fs.existsSync(configPath)) {\n    config = require(configPath).applications[application];\n  } else if (process.env.hasOwnProperty(\"bamboo_oauth_config_path\")) {\n    config = require(process.env.bamboo_oauth_config_path).applications[application];\n  } else if (process.env.CI) {\n    config = require(defaultConfigPath).applications[application];\n    /*eslint camelcase:0 no-console:0*/\n    console.log(\"Using default config and keys from CI environment\");\n    config.consumer_key = process.env.consumer_key;\n    config.consumer_secret = process.env[application + '_consumer_secret'];\n    config.access_token = process.env[application + '_access_token'];\n    config.access_token_secret = process.env[application + '_access_token_secret'];\n  }\n  return config;\n};\n"
  },
  {
    "__docId__": 29,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/utils/config.js",
    "longname": "lib/utils/config.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/utils/config.js",
    "importStyle": null,
    "description": "Application configuration utility",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "utils/config"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} configuration for application"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "application",
        "description": "application"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "configuration for application"
    },
    "generator": false
  },
  {
    "__docId__": 30,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/utils/david.js",
    "memberof": null,
    "longname": "lib/utils/david.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\r\n\r\n/**\r\n * David build utilities\r\n * @exports utils/david\r\n * @param {bunyan} logger - A logger matching the bunyan API\r\n * @returns {Object} David build utility functions\r\n */\r\nmodule.exports = function davidUtils(logger) {\r\n  var david = require(\"david\");\r\n  var fs = require(\"fs\");\r\n  var vasync = require(\"vasync\");\r\n  var _ = require(\"underscore\");\r\n\r\n  var exports = {\r\n\r\n    /**\r\n     * Generate a dependency report in the mocha output format.\r\n     * @param {Object} manifest - Parsed package.json file contents\r\n     * @param {Object} [opts] Options\r\n     * @param {Object} [opts.reportType=\"mocha\"] - The report output format.  Choose from mocha or cucumber.\r\n     * @param {Object} [opts.reportPath] - The output path for the report\r\n     * @param {Boolean} [opts.stable=false] - Consider only stable packages\r\n     * @param {Function} cb Function that receives the results\r\n     */\r\n    \"dependencyReport\": function dependencyReport(manifest, opts, cb) {\r\n      var self = this;\r\n      var checks = [];\r\n      var reportWriter;\r\n      var report;\r\n      opts = _.defaults(opts, {\r\n        \"stable\": false,\r\n        \"reportType\": \"mocha\",\r\n        \"dev\": false,\r\n        \"optional\": false\r\n      });\r\n      //capitalise first character of reportType for require()\r\n      opts.reportType = opts.reportType.charAt(0).toUpperCase() + opts.reportType.slice(1);\r\n      reportWriter = require(\"../reports/david\" + opts.reportType)();\r\n      report = reportWriter.prepare();\r\n\r\n      //add dependency checks\r\n      checks.push(\r\n        function production(arg, callback) {\r\n          logger.info(\"Checking production dependencies\");\r\n          opts.suite = \"Production dependencies\";\r\n          opts.dev = false;\r\n          opts.optional = false;\r\n          self.recordDependencies(manifest, opts, report, reportWriter, callback);\r\n        });\r\n      if (opts.dev) {\r\n        checks.push(\r\n          function dependencies(arg, callback) {\r\n            logger.info(\"Checking development dependencies\");\r\n            opts.suite = \"Development dependencies\";\r\n            opts.dev = true;\r\n            opts.optional = false;\r\n            self.recordDependencies(manifest, opts, report, reportWriter, callback);\r\n          });\r\n      }\r\n      if (opts.optional) {\r\n        checks.push(\r\n          function optionalDependencies(arg, callback) {\r\n            logger.info(\"Checking optional dependencies\");\r\n            opts.suite = \"Optional dependencies\";\r\n            opts.dev = false;\r\n            opts.optional = true;\r\n            self.recordDependencies(manifest, opts, report, reportWriter, callback);\r\n          });\r\n      }\r\n\r\n      vasync.pipeline({\"funcs\": checks}, function dependencyCheckCallback(err) {\r\n        if (!err) {\r\n          reportWriter.writeToFileSync(opts.reportPath, report);\r\n        }\r\n        cb(err);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Record the result of dependency checks against all provided dependencies of a particular type\r\n     * in the report object. The david.isUpdated() function.\r\n     * @param {Object} manifest Parsed package.json file contents\r\n     * @param {Object} [opts] Options\r\n     * @param {String} [opts.suite]  - the dependency type string description\r\n     * @param {Boolean} [opts.stable] Consider only stable packages\r\n     * @param {Boolean} [opts.dev] Consider devDependencies\r\n     * @param {Boolean} [opts.optional] Consider optionalDependencies\r\n     * @param {Boolean} [opts.peer] Consider peerDependencies\r\n     * @param {Boolean} [opts.loose] Use loose option when querying semver\r\n     * @param {Object} [opts.npm] npm configuration options\r\n     * @param {Boolean} [opts.warn.E404] Collect 404s but don't abort\r\n     * @param {Object} rpt - report object to record results to\r\n     * @param {Object} reportWriter Provides write method to write the result of each package dependency\r\n     * check to the rpt object\r\n     * @param {Function} cb Function that receives the results\r\n     */\r\n    \"recordDependencies\": function recordDependencies(manifest, opts, rpt, reportWriter, cb) {\r\n      david.getDependencies(manifest, opts, function getDependenciesCallback(err, pkgs) {\r\n        Object.keys(pkgs).forEach(function eachPackage(pkg) {\r\n          reportWriter.write(opts, pkgs, pkg, rpt);\r\n        });\r\n        cb(err, rpt);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Add updated dependencies to package.json\r\n     * @param {Object} pathToManifest path to the package.json file\r\n     * @param {Object} [opts] Options\r\n     * @param {Boolean} [opts.stable] Consider only stable packages\r\n     * @param {Boolean} [opts.dev] Provided dependencies are dev dependencies\r\n     * @param {Boolean} [opts.optional] Provided dependencies are optional dependencies\r\n     * @param {Boolean} [opts.peer] Consider peerDependencies\r\n     * @param {Boolean} [opts.loose] Use loose option when querying semver\r\n     * @param {Object} [opts.npm] npm configuration options\r\n     * @param {Boolean} [opts.warn.E404] Collect 404s but don\"t abort\r\n     * @param {Function} cb Callback\r\n     */\r\n    \"addUpdatedDeps\": function addUpdatedDeps(pathToManifest, opts, cb) {\r\n      var manifest = JSON.parse(fs.readFileSync(pathToManifest));\r\n      var type = \"dependencies\";\r\n      if (opts.dev) {\r\n        type = \"devDependencies\";\r\n      } else if (opts.optional) {\r\n        type = \"optionalDependencies\";\r\n      }\r\n      david.getUpdatedDependencies(manifest, opts, function getUpdatedDependenciesCallback(er, pkgs) {\r\n        manifest[type] = manifest[type] || {};\r\n        Object.keys(pkgs).forEach(function eachPackage(pkg) {\r\n          if (pkgs[pkg].required !== \"^\" + pkgs[pkg].stable) {\r\n            manifest[type][pkg] = \"^\" + pkgs[pkg].stable;\r\n            logger.info(\"Updated: \" + pkg + \" to \" + pkgs[pkg].stable);\r\n          }\r\n        });\r\n        fs.writeFileSync(pathToManifest, JSON.stringify(manifest, null, 2));\r\n        cb();\r\n      });\r\n    }\r\n  };\r\n\r\n  return exports;\r\n};\r\n"
  },
  {
    "__docId__": 31,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/utils/david.js",
    "longname": "lib/utils/david.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/utils/david.js",
    "importStyle": null,
    "description": "David build utilities",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "utils/david"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} David build utility functions"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bunyan"
        ],
        "spread": false,
        "optional": false,
        "name": "logger",
        "description": "A logger matching the bunyan API"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "David build utility functions"
    },
    "generator": false
  },
  {
    "__docId__": 32,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/utils/jira.js",
    "memberof": null,
    "longname": "lib/utils/jira.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\r\n\r\n/**\r\n * JIRA build utilities\r\n * @exports utils/jira\r\n * @returns {Object} JIRA build utility functions\r\n */\r\nmodule.exports = function jiraUtils() {\r\n  var oauthRest = require(\"oauth-rest-atlassian\").rest;\r\n  var _ = require(\"underscore\");\r\n  var config = require(\"./config\")(\"jira\");\r\n  var vasync = require(\"vasync\");\r\n\r\n  var exports = {\r\n    /**\r\n     * Send query to rest api.\r\n     * @param {Object} opts - required options\r\n     * @param {Object} [opts.query] - the rest query url\r\n     * @param {Object} [opts.method=\"get\"] - optional the http method - one of get, post, put, delete\r\n     * @param {Object} [opts.postData=\"\"] - optional the post data for create or update queries.\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"rest\": function rest(opts, cb) {\r\n      opts = _.defaults(opts, {\r\n        \"config\": config\r\n      });\r\n      oauthRest(opts, cb);\r\n    },\r\n\r\n    /**\r\n     * Get all JIRA projects.\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"getProjects\": function getProjects(cb) {\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"project\"\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Create a JIRA issue.\r\n     * @param {Object} issue - object map with properties required to create the issue\r\n     * @param {String} issue.key - key for the JIRA project to create the issue within\r\n     * @param {String} issue.summary - the summary description for the issue\r\n     * @param {String} issue.issueType - the name of the issue type\r\n     * @param {String} issue.version - the release version for the issue (fixversion)\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"createIssue\": function createIssue(issue, cb) {\r\n      //create update task in JIRA (non-func issue type) and get issue key\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"issue\",\r\n        \"method\": \"post\",\r\n        \"postData\": {\r\n          \"fields\": {\r\n            \"project\": {\r\n              \"key\": issue.key\r\n            },\r\n            \"summary\": issue.summary,\r\n            \"issuetype\": {\r\n              \"name\": issue.issueType\r\n            },\r\n            \"fixVersions\": [\r\n              {\r\n                \"name\": issue.version\r\n              }\r\n            ]\r\n          }\r\n        }\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Delete a JIRA issue.\r\n     * @param {String} key - the key for the JIRA issue to delete\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"deleteIssue\": function deleteIssue(key, cb) {\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"issue/\" + key,\r\n        \"method\": \"delete\"\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Create a new version in a JIRA project.\r\n     * @param {String} key - the JIRA project key\r\n     * @param {String} version - the version (semver)\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"createVersion\": function createVersion(key, version, cb) {\r\n      oauthRest({\r\n          \"config\": config,\r\n          \"query\": \"version\",\r\n          \"method\": \"post\",\r\n          \"postData\": {\r\n            \"project\": key,\r\n            \"name\": version\r\n          }\r\n        },\r\n        function createVersionCallback(err, data) {\r\n          cb(err, data);\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Delete an existing version in a JIRA project.\r\n     * @param {String} key - the JIRA project key\r\n     * @param {String} version - the version (semver)\r\n     * @param {Function} cb - callback function with signature: function(err)\r\n     */\r\n    \"deleteVersion\": function deleteVersion(key, version, cb) {\r\n      vasync.waterfall([\r\n        function getProjectVersions(callback) {\r\n          oauthRest({\r\n            \"config\": config,\r\n            \"query\": \"project/\" + key + \"/versions\"\r\n          }, callback);\r\n        },\r\n        function getVersionAndDelete(versions, callback) {\r\n          var versionObj = _.find(versions, function matchVersion(v) {\r\n            return v.name === version;\r\n          });\r\n          if (versionObj) {\r\n            oauthRest({\r\n              \"config\": config,\r\n              \"query\": \"version/\" + versionObj.id,\r\n              \"method\": \"delete\"\r\n            }, callback);\r\n          } else {\r\n            callback(\"Version \" + version + \" not found in project \" + key);\r\n          }\r\n        }\r\n      ], cb);\r\n    },\r\n\r\n    /**\r\n     * Release a version in a JIRA project.\r\n     * The version will only be released if there are 0 unresolved issue linked to version.\r\n     * @param {String} key - the JIRA project key\r\n     * @param {String} version - the version (semver)\r\n     * @param {Date} releaseDate - the release date\r\n     * @param {Function} cb - callback function with signature: function(err, versionObj)\r\n     * Where versionObj is an object with the following properties:\r\n     * versionObj.id {String} - the version id\r\n     * versionObj.name {String} - the version (semver)\r\n     * versionObj.released {Boolean} - has the version been released\r\n     * versionObj.releaseDate {String} - the planned (if released=false) or actual (if released=true) release date\r\n     * versionObj.issuesUnresolvedCount {Number} - the number of unresolved issue linked to version\r\n     */\r\n    \"releaseVersion\": function releaseVersion(key, version, releaseDate, cb) {\r\n      //convert date to a string in format YYYY-MM-DD\r\n      var releaseDateStr =\r\n        releaseDate.getFullYear() + \"-\" +\r\n        (\"\" + (releaseDate.getMonth() + 1)).slice(-2) + \"-\" +\r\n        (\"0\" + releaseDate.getDate()).slice(-2);\r\n\r\n      vasync.waterfall([\r\n        function getProjectVersions(callback) {\r\n          oauthRest({\r\n            \"config\": config,\r\n            \"query\": \"project/\" + key + \"/versions\"\r\n          }, callback);\r\n        },\r\n        function getIssuesUnresolvedCount(versions, callback) {\r\n          var versionObj = _.find(versions, function matchVersion(v) {\r\n            return v.name === version;\r\n          });\r\n          if (versionObj) {\r\n            oauthRest({\r\n              \"config\": config,\r\n              \"query\": \"version/\" + versionObj.id + \"/unresolvedIssueCount\"\r\n            }, function getVersionCallback(err, data) {\r\n              data = data || {};\r\n              versionObj.issuesUnresolvedCount = data.issuesUnresolvedCount;\r\n              callback(err, versionObj);\r\n            });\r\n          } else {\r\n            callback(\"Version \" + version + \" not found in project \" + key);\r\n          }\r\n        },\r\n        function releaseIfZeroIssuesUnresolved(versionObj, callback) {\r\n          if (versionObj.issuesUnresolvedCount === 0) {\r\n            oauthRest({\r\n                \"config\": config,\r\n                \"query\": \"version/\" + versionObj.id,\r\n                \"method\": \"put\",\r\n                \"postData\": {\r\n                  \"released\": true,\r\n                  \"releaseDate\": releaseDateStr\r\n                }\r\n              },\r\n              function getVersionCallback(err) {\r\n                if (!err) {\r\n                  versionObj.released = true;\r\n                  versionObj.releaseDate = releaseDateStr;\r\n                }\r\n                callback(err, versionObj);\r\n              });\r\n          } else {\r\n            //Note: versionObj.released will remain false\r\n            callback(null, versionObj);\r\n          }\r\n        }\r\n      ], cb);\r\n    },\r\n\r\n    /**\r\n     * Transition a JIRA issue.\r\n     * @param {String} key - key for the JIRA issue to transition\r\n     * @param {String} transition - the transition id\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"transitionIssue\": function transitionIssue(key, transition, cb) {\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"issue/\" + key + \"/transitions\",\r\n        \"method\": \"post\",\r\n        \"postData\": {\r\n          \"transition\": {\r\n            \"id\": transition\r\n          }\r\n        }\r\n      }, cb);\r\n    },\r\n\r\n    /**\r\n     * Get the next unresolved and unreleased minor version for the project (based on semver).\r\n     * If there is an existing unresolved and unreleased major or minor version then the earliest is returned.\r\n     * @param {String} key - the JIRA project key\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"getNextUnreleasedPatchVersion\": function getNextUnreleasedPatchVersion(key, cb) {\r\n      var self = this;\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": \"project/\" + key + \"/versions\"\r\n      }, function getProjectVersionsCallback(err, versions) {\r\n        var lastReleasedVersion = \"0.0.0\";\r\n        var nextUnreleasedPatchVersion = null;\r\n        var releasedVersions;\r\n        var unreleasedVersions;\r\n        var lastReleasedVersionArray;\r\n\r\n        if (!err) {\r\n          if (versions.length > 0) {\r\n            //sort in semver order (assumes name of version is in semver format)\r\n            versions = _.sortBy(versions, function semanticVersionSorter(version) {\r\n              var versionArray = version.name.split(\".\");\r\n              version =\r\n                parseInt(versionArray[0], 10) * 1000000 +\r\n                parseInt(versionArray[1], 10) * 1000 +\r\n                parseInt(versionArray[2], 10);\r\n              return version;\r\n            });\r\n\r\n            //get released versions\r\n            releasedVersions = _.filter(versions, function releasedVersionFilter(version) {\r\n              return version.released && !version.archived;\r\n            });\r\n            //get latest released version\r\n            if (releasedVersions.length > 0) {\r\n              lastReleasedVersion = releasedVersions[releasedVersions.length - 1].name;\r\n            }\r\n\r\n            //get unreleased versions\r\n            unreleasedVersions = _.filter(versions, function unreleasedVersionFilter(version) {\r\n              return !version.released && !version.archived;\r\n            });\r\n            //get earliest patch version\r\n            if (unreleasedVersions.length > 0 &&\r\n              parseInt(unreleasedVersions[0].name.split(\".\")[2], 10) > 0) {\r\n              nextUnreleasedPatchVersion = unreleasedVersions[0].name;\r\n            }\r\n          }\r\n\r\n          if (nextUnreleasedPatchVersion === null) {\r\n            //create new patch version\r\n            lastReleasedVersionArray = lastReleasedVersion.split(\".\");\r\n            nextUnreleasedPatchVersion =\r\n              lastReleasedVersionArray[0] + \".\" +\r\n              lastReleasedVersionArray[1] + \".\" +\r\n              (parseInt(lastReleasedVersionArray[2], 10) + 1);\r\n\r\n            self.createVersion(key, nextUnreleasedPatchVersion,\r\n              function createVersionCallback(err2, version) {\r\n                nextUnreleasedPatchVersion = null;\r\n                if (!err2) {\r\n                  nextUnreleasedPatchVersion = version.name;\r\n                }\r\n                cb(err2, nextUnreleasedPatchVersion);\r\n              });\r\n          } else {\r\n            cb(err, nextUnreleasedPatchVersion);\r\n          }\r\n        } else {\r\n          cb(err, nextUnreleasedPatchVersion);\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Get the changelog for a JIRA project.\r\n     * @param {String} key - the JIRA project key\r\n     * @param {Function} cb - callback function with signature: function(err, data)\r\n     */\r\n    \"getChangelog\": function getChangelog(key, cb) {\r\n      var self = this;\r\n      var jiraQuery = \"search?jql=(project = \" + key + \" AND \" +\r\n        \"issuetype in standardIssueTypes() AND issuetype != Task AND \" +\r\n        \"resolution != Unresolved AND \" +\r\n        \"fixVersion in (unreleasedVersions(), releasedVersions())) \" +\r\n        \"ORDER BY fixVersion DESC, resolutiondate DESC\";\r\n      var queryFields =\r\n        \"&fields=*all\";\r\n      oauthRest({\r\n        \"config\": config,\r\n        \"query\": jiraQuery + queryFields\r\n      }, function getChangelogCallback(err, data) {\r\n        cb(err, self.prepareChangeLogJSON(data));\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Tranform raw changelog data from a JQL query into a JSON object.\r\n     * @param {Object} data - raw changelog data\r\n     * @returns {Object} changelog JSON object\r\n     * @example\r\n     Raw changelog data:\r\n     ```\r\n     {\r\n     \"releases\": [\r\n         {\r\n           \"version\": {\r\n             \"self\": \"https://jira.cellarise.com/rest/api/2/version/10516\",\r\n             \"id\": \"10516\",\r\n             \"name\": \"0.1.4\",\r\n             \"archived\": false,\r\n             \"released\": true,\r\n             \"releaseDate\": \"2014-08-28\"\r\n           },\r\n           \"issues\": []\r\n         }\r\n     }\r\n     ```\r\n     */\r\n    \"prepareChangeLogJSON\": function prepareChangeLogJSON(data) {\r\n      var changeLogJSON = {\r\n          \"releases\": []\r\n        },\r\n        i,\r\n        issues,\r\n        currentIssue,\r\n        currentVersion,\r\n        release,\r\n        releaseNum = -1,\r\n        date = new Date();\r\n\r\n      if (!data) {\r\n        return {};\r\n      }\r\n\r\n      issues = data.issues;\r\n\r\n      for (i = 0; i < issues.length; i = i + 1) {\r\n        currentIssue = issues[i];\r\n        currentVersion = currentIssue.fields.fixVersions[0];\r\n        //first version or check for change in version\r\n        if (!release || release.name !== currentVersion.name) {\r\n          //check if version date set, otherwise set to current date\r\n          if (!currentVersion.releaseDate) {\r\n            currentVersion.releaseDate = date.getFullYear() + \"-\" +\r\n              (\"0\" + (date.getMonth() + 1)).slice(-2) + \"-\" +\r\n              (\"0\" + date.getDate()).slice(-2);\r\n          }\r\n          release = currentVersion;\r\n          releaseNum = releaseNum + 1;\r\n          changeLogJSON.releases[releaseNum] = {\r\n            \"version\": currentVersion,\r\n            \"issues\": []\r\n          };\r\n        }\r\n        //add issue to release\r\n        changeLogJSON.releases[releaseNum].issues.push({\r\n          \"key\": currentIssue.key,\r\n          \"summary\": currentIssue.fields.summary,\r\n          \"description\": currentIssue.fields.description,\r\n          \"issuetype\": currentIssue.fields.issuetype,\r\n          \"status\": currentIssue.fields.status,\r\n          \"priority\": currentIssue.fields.priority,\r\n          \"resolution\": currentIssue.fields.resolution,\r\n          \"components\": currentIssue.fields.components,\r\n          \"resolutiondate\": currentIssue.fields.resolutiondate\r\n        });\r\n      }\r\n      return changeLogJSON;\r\n    }\r\n  };\r\n\r\n  return exports;\r\n};\r\n"
  },
  {
    "__docId__": 33,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/utils/jira.js",
    "longname": "lib/utils/jira.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/utils/jira.js",
    "importStyle": null,
    "description": "JIRA build utilities",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "utils/jira"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} JIRA build utility functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "JIRA build utility functions"
    },
    "generator": false
  },
  {
    "__docId__": 34,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/utils/postBuild.js",
    "memberof": null,
    "longname": "lib/utils/postBuild.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\r\n\r\n/**\r\n * Post build utilities\r\n * @exports utils/postBuild\r\n * @param {bunyan} logger - A logger matching the bunyan API\r\n * @returns {Object} Post build utility functions\r\n */\r\nmodule.exports = function postBuildUtils(logger) {\r\n  var vasync = require(\"vasync\");\r\n  var path = require(\"path\");\r\n  var fs = require(\"fs\");\r\n  var results = [];\r\n\r\n  var exports = {\r\n    /**\r\n     * Check whether a file or directory path exists and if not record an error message in the provided results object.\r\n     * @param {String} testPath - the path to test from the current working directory\r\n     * @param {String} cwd - the current working directory\r\n     * @param {Object} result - the result object to record an error message if file or directory path does not exist\r\n     * @returns {Boolean} true if the file or directory path exists\r\n     */\r\n    \"pathExists\": function pathExists(testPath, cwd, result) {\r\n      var message = \"Build directory/file \" + testPath + \" does not exist. \";\r\n      if (!fs.existsSync(path.join(cwd, \"Build\", testPath))) {\r\n        logger.error(message);\r\n        result.errorMessages.push(message);\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    /**\r\n     * Check whether a file or directory path exists and if so record an error message in the provided results object.\r\n     * @param {String} testPath - the path to test from the current working directory\r\n     * @param {String} cwd - the current working directory\r\n     * @param {Object} result - the result object to record an error message if file or directory path exists\r\n     * @returns {Boolean} true if the file or directory path does not exist\r\n     */\r\n    \"pathNotExists\": function pathNotExists(testPath, cwd, result) {\r\n      var message = \"Build directory/file \" + testPath + \" exists. \";\r\n      if (fs.existsSync(path.join(cwd, \"Build\", testPath))) {\r\n        logger.error(message);\r\n        result.errorMessages.push(message);\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    /**\r\n     * Post build checks including:\r\n     * Check that build directory exists and contains expected contents\r\n     * @param {Object} directories - the directories listed in package.json\r\n     * @param {String} cwd - the current working directory\r\n     * @param {Function} cb - callback\r\n     */\r\n    \"checks\": function checks(directories, cwd, cb){\r\n      var self = this;\r\n      vasync.parallel({\r\n        \"funcs\": [\r\n          function checkBuildDirectory(callback) {\r\n            var result = {\r\n              \"testName\": \"Check that build directory exists and contains expected contents\",\r\n              \"errorMessages\": []\r\n            };\r\n            if (self.pathExists(\"\", cwd, result)){\r\n              self.pathNotExists(directories.reports, cwd, result);\r\n              self.pathExists(\".gitignore\", cwd, result);\r\n              self.pathExists(\".eslintrc\", cwd, result);\r\n              self.pathExists(\".eslintignore\", cwd, result);\r\n              self.pathExists(\".npmignore\", cwd, result);\r\n            }\r\n            results.push(result);\r\n            callback();\r\n          },\r\n          function checkPackageJSON(callback) {\r\n            var buildPackageJSON;\r\n            var result = {\r\n              \"testName\": \"Check build package.json exists and contains expected properties\",\r\n              \"errorMessages\": []\r\n            };\r\n            if (self.pathExists(\"package.json\", cwd, result)){\r\n              buildPackageJSON = require(path.join(cwd, \"Build/package.json\"));\r\n              if (buildPackageJSON.config.build === \"n/a\"){\r\n                result.errorMessages.push(\"Build number not set. \");\r\n              }\r\n            }\r\n            results.push(result);\r\n            callback();\r\n          }\r\n        ]\r\n      }, function postBuildParallelCallback(err) {\r\n        require(\"../reports/postBuildMocha\")(\r\n          \"Post build\",\r\n          results,\r\n          path.join(cwd, directories.reports, \"postBuild-mocha-tests.json\"));\r\n        require(\"../reports/postBuildCucumber\")(\r\n          \"Post build\",\r\n          results,\r\n          path.join(cwd, directories.reports, \"cucumber-tests.json\"));\r\n        cb(err);\r\n      });\r\n    }\r\n  };\r\n\r\n  return exports;\r\n};\r\n"
  },
  {
    "__docId__": 35,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/utils/postBuild.js",
    "longname": "lib/utils/postBuild.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/utils/postBuild.js",
    "importStyle": null,
    "description": "Post build utilities",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "utils/postBuild"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Post build utility functions"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bunyan"
        ],
        "spread": false,
        "optional": false,
        "name": "logger",
        "description": "A logger matching the bunyan API"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Post build utility functions"
    },
    "generator": false
  },
  {
    "__docId__": 36,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "lib/utils/reports.js",
    "memberof": null,
    "longname": "lib/utils/reports.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "\"use strict\";\r\n\r\n/**\r\n * Build report utilities\r\n * @exports utils/reports\r\n * @returns {Object} Build report utility functions\r\n */\r\nmodule.exports = function reportUtils() {\r\n  var glob = require(\"glob\");\r\n  var fs = require(\"fs\");\r\n\r\n  var exports = {\r\n    /**\r\n     * Check all mocha test reports and return true if all tests passed or false if one or more tests failed.\r\n     * @param {String} reportDir - the directory containing the mocha test reports.\r\n     * @returns {Boolean} true if all tests passed or false if one or more tests failed\r\n     */\r\n    \"checkReportsPass\": function checkReportsPass(reportDir) {\r\n      //get reports\r\n      var reports = glob.sync(process.cwd() + \"/\" + reportDir + \"/**/*mocha-tests.json\");\r\n      //iterate over reports\r\n      var i, pass = true;\r\n      for (i = 0; i < reports.length; i = i + 1) {\r\n        if (JSON.parse(fs.readFileSync(reports[i])).stats.failures > 0) {\r\n          pass = false;\r\n        }\r\n      }\r\n      return pass;\r\n    },\r\n    /**\r\n     * Check all mocha test reports and return an array containing all failures.\r\n     * @param {String} reportDir - the directory containing the mocha test reports.\r\n     * @returns {Array} - return array containing all failures\r\n     */\r\n    \"getReportFailures\": function getReportFailures(reportDir) {\r\n      //get reports\r\n      var reports = glob.sync(process.cwd() + \"/\" + reportDir + \"/**/*mocha-tests.json\");\r\n      var rpt;\r\n      var failures = [];\r\n      //iterate over reports\r\n      var i;\r\n      for (i = 0; i < reports.length; i = i + 1) {\r\n        rpt = JSON.parse(fs.readFileSync(reports[i]));\r\n        if (rpt.stats.failures > 0) {\r\n          failures = failures.concat(rpt.failures);\r\n        }\r\n      }\r\n      return failures;\r\n    }\r\n  };\r\n\r\n  return exports;\r\n};\r\n"
  },
  {
    "__docId__": 37,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "exports",
    "memberof": "lib/utils/reports.js",
    "longname": "lib/utils/reports.js~exports",
    "access": null,
    "export": false,
    "importPath": "cellarise-package-manager/lib/utils/reports.js",
    "importStyle": null,
    "description": "Build report utilities",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@exports",
        "tagValue": "utils/reports"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Build report utility functions"
      }
    ],
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Build report utility functions"
    },
    "generator": false
  },
  {
    "__docId__": 39,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 49,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 50,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 51,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 52,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 53,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 54,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 55,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 56,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 57,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 58,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 59,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 60,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 61,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 62,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 63,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 64,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 65,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 66,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 67,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 68,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 69,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 70,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 71,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 72,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 73,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 74,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 75,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 76,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 77,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 78,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 79,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 80,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 81,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 82,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 83,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 84,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 85,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 87,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 88,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 89,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 90,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 91,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 92,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 93,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 94,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": null,
    "builtinExternal": true
  }
]