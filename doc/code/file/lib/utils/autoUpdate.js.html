<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/utils/autoUpdate.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Cellarise/cellarise-package-manager.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/utils/autoUpdate.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;

/**
 * Auto update build utilities.
 * @exports utils/autoUpdate
 * @param {bunyan} logger - A logger matching the bunyan API
 * @returns {Object} Auto update build utility functions
 */
module.exports = function autoUpdateUtils(logger) {
  var vasync = require(&quot;vasync&quot;);
  var _ = require(&quot;underscore&quot;);
  var jiraUtils = require(&quot;./jira&quot;)(logger);
  var bambooUtils = require(&quot;./bamboo&quot;)(logger);
  var execUtils = require(&quot;../../bin/exec&quot;)(logger);
  var reportUtils = require(&quot;./reports&quot;)();
  var chalk = require(&quot;chalk&quot;);

  var rename = require(&quot;gulp-rename&quot;);
  var path = require(&quot;path&quot;);
  var GulpDustCompileRender = require(&quot;gulp-dust-compile-render&quot;);
  var AsyncPipe = require(&quot;gulp-async-func-runner&quot;);


  var exports = {
    /**
     * Run the update task on all projects matching specified criteria and generate output reports.
     * @param {Object} opts - options
     * @param {String} [opts.repositoryUrl] - the url to the repository containing packages for checking and update
     * @param {String} [opts.BUILD_DIR=&quot;Build&quot;] - download the repository to this temporary build directory
     * @param {String} [opts.category=&quot;&quot;] - all projects with this JIRA project category
     * are to be included on the update
     * @param {Array} [opts.include=[]] - array of short repository paths to be included in the update
     * @param {Array} [opts.exclude=[]] - array of short repository paths to be excluded in the update
     * @param {Boolean} [opts.updateCheck=false] - flag whether to run tasks to auto-check
     * whether an update is required
     * @param {String} [opts.updateCheckTask=&quot;all&quot;] - gulp task used to auto-check whether an update is required
     * @param {Boolean} [opts.updateSource=false] - flag whether to run tasks to auto-update the source
     * and then commit
     * @param {String} [opts.updateSourceTask=&quot;all&quot;] - gulp task used to auto-update the source
     * @param {String} [opts.updateSourceSummary=&quot;&quot;] - the summary description for the issue created to track
     * source update progress
     * @param {String} [opts.updateSourceType=&quot;Non-functional&quot;] - the issue type for the issue created to track
     * source update progress
     * @param {String} [opts.bambooBuildTask=&quot;all&quot;] - gulp task used for Bamboo build
     * @param {String} [opts.bambooPostBuildTask=&quot;post_build&quot;] - gulp task used for Bamboo post build
     * @param {Function} gulp - gulp object used to wrap the `autoUpdate` function in a gulp task
     * @param {Object} context - context object passed to gulp tasks used to obtain context.cwd - current working
     * directory
     * @returns {through2} stream
     */
    &quot;run&quot;: function run(opts, gulp, context) {
      var self = this;
      var results = {};
      var directories = context.package.directories || {};
      var reportPath = path.join(context.cwd, directories.reports || &quot;reports&quot;);
      return gulp.src(path.join(__dirname, &quot;../../tasks/templates/auto-update-report.dust&quot;))
        .pipe(new AsyncPipe({
            &quot;oneTimeRun&quot;: true,
            &quot;passThrough&quot;: true
          },
          function runAutoUpdate(op, chunk, cb) {
            self.autoUpdate(opts, cb);
          },
          function writeReports(error, autoUpdateWorkflows) {
            //save results for reports
            var reportWriter = require(&quot;../reports/autoUpdateMocha&quot;)();
            var report = reportWriter.prepare();

            logger.debug(JSON.stringify(autoUpdateWorkflows, null, 2));

            _.each(autoUpdateWorkflows, function eachAutoUpdateWorkflow(workflowHistory) {
              //ensure properties exist
              _.defaults(workflowHistory, {
                &quot;bambooTest&quot;: {
                  &quot;buildState&quot;: null
                },
                &quot;releasedVersion&quot;: {
                  &quot;name&quot;: null,
                  &quot;issuesUnresolvedCount&quot;: null
                },
                &quot;bambooRelease&quot;: {
                  &quot;buildNumber&quot;: null,
                  &quot;buildState&quot;: null
                }
              });
              reportWriter.write(workflowHistory, report);
            });
            reportWriter.writeToFileSync(reportPath + &quot;/autoUpdate-mocha-tests.json&quot;, report);
            results.projects = autoUpdateWorkflows;
          }))
        .pipe(new GulpDustCompileRender(results))
        .pipe(rename(function renameExtension(renamePath) {
            renamePath.extname = &quot;.html&quot;;
        }))
        .pipe(gulp.dest(reportPath));
    },

    /**
     * Execute update task on all projects matching specified criteria.
     * @param {Object} opts - options
     * @param {String} [opts.repositoryUrl] - the url to the repository containing packages for checking and update
     * @param {String} [opts.BUILD_DIR=&quot;Build&quot;] - download the repository to this temporary build directory
     * @param {String} [opts.category=&quot;&quot;] - all projects with this JIRA project category are
     * to be included on the update
     * @param {Array} [opts.include=[]] - array of short repository paths to be included in the update
     * @param {Array} [opts.exclude=[]] - array of short repository paths to be excluded in the update
     * @param {Boolean} [opts.updateCheck=false] - flag whether to run tasks to auto-check whether
     * an update is required
     * @param {String} [opts.updateCheckTask=&quot;all&quot;] - gulp task used to auto-check whether an update is required
     * @param {Boolean} [opts.updateSource=false] - flag whether to run tasks to auto-update the source
     * and then commit
     * @param {String} [opts.updateSourceTask=&quot;all&quot;] - gulp task used to auto-update the source
     * @param {String} [opts.updateSourceSummary=&quot;&quot;] - the summary description for the issue created to track
     * source update progress
     * @param {String} [opts.updateSourceType=&quot;Non-functional&quot;] - the issue type for the issue created to track
     * source update progress
     * @param {String} [opts.bambooBuildTask=&quot;all&quot;] - gulp task used for Bamboo build
     * @param {String} [opts.bambooPostBuildTask=&quot;post_build&quot;] - gulp task used for Bamboo post build
     * @param {Function} cb - callback function with signature: function(err, data)
     * @example
     {&gt;example-autoUpdate/}
     */
    &quot;autoUpdate&quot;: function autoUpdate(opts, cb) {
      var self = this;
      var updateProjectAsyncFuncArray = [];

      logger.info(chalk.cyan(&quot;Starting auto update task&quot;));
      opts = opts || {};
      _.defaults(opts, {
        &quot;BUILD_DIR&quot;: &quot;Build&quot;,
        &quot;category&quot;: &quot;&quot;,
        &quot;include&quot;: [],
        &quot;exclude&quot;: [],
        &quot;updateCheck&quot;: false,
        &quot;updateCheckTask&quot;: &quot;all&quot;,
        &quot;updateSource&quot;: false,
        &quot;updateSourceTask&quot;: &quot;all&quot;,
        &quot;updateSourceSummary&quot;: &quot;&quot;,
        &quot;updateSourceType&quot;: &quot;Non-functional&quot;,
        &quot;bambooBuildTask&quot;: &quot;all&quot;,
        &quot;bambooPostBuildTask&quot;: &quot;post_build&quot;
      });

      //get start list of projects to check/update using project category
      jiraUtils.getProjects(function getProjectsCallback(error, data) {
        var i;
        var updateProjectFunc = function updateProjectFunc(repositoryPath, project) {
          var buildPlanName = repositoryPath.split(&quot;/&quot;).join(&quot; - &quot;).toLowerCase();
          //need to convert the avatarUrls properties to start with a character
          //so that dust template can use them.
          project.avatarUrls.xsmall = project.avatarUrls[&quot;16x16&quot;];
          project.avatarUrls.small = project.avatarUrls[&quot;24x24&quot;];
          project.avatarUrls.medium = project.avatarUrls[&quot;32x32&quot;];
          project.avatarUrls.large = project.avatarUrls[&quot;48x48&quot;];
          project.shortName = project.name.split(&quot;/&quot;)[1];
          return function updateProject(arg, callback) {
            _.extend(opts, {
              &quot;buildPlanName&quot;: buildPlanName,
              &quot;repositoryPath&quot;: repositoryPath,
              &quot;project&quot;: project
            });
            self.updateProject(opts, function updateProjectCallback(err, workflowHistory) {
              callback(err, workflowHistory);
            });
          };
        };

        if (!error) {
          for (i = 0; i &lt; data.length; i = i + 1) {
            if ((data[i].projectCategory &amp;&amp; data[i].projectCategory.name === opts.category ||
              _.contains(opts.include, data[i].key)) &amp;&amp; !_.contains(opts.exclude, data[i].key)) {
              updateProjectAsyncFuncArray.push(updateProjectFunc(data[i].name, data[i]));
            }
          }
          vasync.pipeline({
            &quot;funcs&quot;: updateProjectAsyncFuncArray
          }, function updateProjectAsyncFuncArrayCallback(err, results) {
            logger.info(chalk.cyan(&quot;Finished auto update task&quot;));
            cb(err, results.successes);
          });
        } else {
          cb(error);
        }
      });
    },

    /**
     * Execute update task on a project.
     * @param {Object} opts - options
     * @param {String} opts.BUILD_DIR - download the repository to this temporary build directory
     * @param {String} opts.repositoryUrl - the url to the repository containing packages for checking and update
     * @param {String} opts.repositoryPath - short repository path of project to be processed
     * @param {Object} opts.project - the JIRA project metadata
     * @param {Boolean} opts.updateCheck - flag whether to run tasks to auto-check whether an update is required
     * @param {String} opts.updateCheckTask - gulp task used to auto-check whether an update is required
     * @param {Boolean} opts.updateSource - flag whether to run tasks to auto-update the source and then commit
     * @param {String} opts.updateSourceTask - gulp task used to auto-update the source
     * @param {Boolean} opts.releaseVersion - flag whether to release the patch version for an update
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;updateProject&quot;: function updateProject(opts, cb) {
      var self = this;
      var workflowHistory = {
        &quot;project&quot;: opts.project,
        &quot;clearFolder&quot;: null,
        &quot;updateCheck&quot;: null,
        &quot;updateCheckText&quot;: null,
        &quot;updateSourceJiraIssue&quot;: null,
        &quot;bambooTest&quot;: null,
        &quot;bambooRelease&quot;: null,
        &quot;transitionedIssue&quot;: null,
        &quot;releasedVersion&quot;: null,
        &quot;clearedBuildFolder&quot;: null
      };

      logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Starting auto update&quot;));

      vasync.waterfall([
        function preAutoUpdate(callback) {
          logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Pre auto update&quot;));
          logger.debug(&quot;CPM clear folder: &quot; + opts.BUILD_DIR);
          execUtils.clearFolder(opts.BUILD_DIR, function clearFolderCallback(err) {
            workflowHistory.clearFolder = &quot;Cleared folder &quot; + opts.BUILD_DIR;
            callback(err);
          });
        },
        function updateCheck(callback) {
          if (opts.updateCheck) {
            logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Update check&quot;));
            self.updateCheck(opts, function updateCheckCallback(err, reportFailures) {
              if (!err) {
                workflowHistory.updateCheck = &quot;&quot; + (reportFailures.length &gt; 0);
                callback(null, reportFailures.length &gt; 0);
              } else {
                callback(err, false);//set to false to stop workflow
              }
            });
          } else {
            callback(null, true); //updateRequired=true if no updateCheck required
          }
        },
        function updateSource(updateRequired, callback) {
          if (updateRequired &amp;&amp; opts.updateSource) { //updateRequired will be true if no check performed
            logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Update source&quot;));
            self.updateSource(opts, function updateSourceCallback(err, issue) {
              //JIRA issue created to record update task
              workflowHistory.updateSourceJiraIssue = issue;
              callback(err, updateRequired &amp;&amp; err === null, issue);
            });
          } else {
            //buildRequired=true &amp;&amp; updateRequired if no updateSource required
            callback(null, updateRequired, null);
          }
        },
        function testBuild(buildRequired, issue, callback) {
          if (buildRequired &amp;&amp; issue !== null) {
            logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Test build&quot;));
            logger.info(&quot;Bamboo trigger build: &quot; + opts.buildPlanName);
            bambooUtils.triggerBamboo(opts.buildPlanName, {
              &quot;gulp_task&quot;: opts.bambooBuildTask,
              &quot;gulp_post_task&quot;: opts.bambooPostBuildTask
            }, function triggerBambooCallback(err, buildResult) {
              workflowHistory.bambooTest = buildResult;
              callback(err, buildResult, issue);
            });
          } else {
            callback(null, null, issue); //buildRequired=false
          }
        },
        function releaseBuild(buildResult, issue, callback) {
          if (opts.releaseVersion &amp;&amp; buildResult &amp;&amp; buildResult.successful) {
            logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Release build&quot;));
            self.releaseBuild(issue, workflowHistory, opts, function releaseBuildCallback(err) {
              callback(err);
            });
          } else {
            callback(null);
          }
        },
        function postAutoUpdate(callback) {
          logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Post auto update&quot;));
          logger.debug(&quot;CPM clear folder: &quot; + opts.BUILD_DIR);
          execUtils.clearFolder(opts.BUILD_DIR, function clearFolderCallback(err) {
            workflowHistory.clearedBuildFolder = true;
            callback(err);
          });
        }
      ], function finishAutoUpdate(err) {
        logger.info(opts.project.key + &quot; &quot; + opts.project.name + &quot;: &quot; + chalk.magenta(&quot;Finished auto update&quot;));
        cb(err, workflowHistory);
      });
    },

    /**
     * Check whether an update is required by cloning the master branch of the project to a directory and
     * running a provided gulp task. The provided gulp task is expected to generate test reports.
     * The test reports are checked for any failures. If one or more failures found then this function
     * will return false in the callback data. Otherwise this function will return true in the callback data.
     * @param {Object} opts - options
     * @param {String} opts.BUILD_DIR - download the repository to this temporary build directory
     * @param {String} opts.repositoryUrl - the url to the repository containing packages for checking and update
     * @param {String} opts.repositoryPath - short repository path of project to be cloned to the BUILD_DIR
     * @param {String} opts.updateCheckTask - gulp task used to perform the update check
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;updateCheck&quot;: function updateCheck(opts, cb) {
      vasync.waterfall([
        function cloneProjectFromGit(callback) {
          execUtils.cloneFromGit(opts.repositoryUrl + opts.repositoryPath, opts.BUILD_DIR, null,
            function cloneFromGitCallback(err, stdout) {
              callback(err, stdout);
            });
        },
        function runUpdateCheckTask(data, callback) {
          execUtils.runGulpTask(opts.updateCheckTask, process.cwd() + &quot;/&quot; + opts.BUILD_DIR,
            function runGulpTaskCallback(err, cbData) {
              callback(err, cbData);
            });
        },
        function getReportFailures(data, callback) {
          callback(null, reportUtils.getReportFailures(opts.BUILD_DIR + &quot;/Reports&quot;));
        }
      ], cb);
    },

    /**
     * Update the source of a project by cloning the master branch of the project and running the provided
     * gulp task. A JIRA issue is created to track the progress of the update. The issue is transitioned to
     * In Progress and QA. Once the update is complete the source is committed back to the repository triggering
     * a Bamboo build on the master branch.
     * @param {Object} opts - options
     * @param {String} opts.BUILD_DIR - download the repository to this temporary build directory
     * @param {String} opts.repositoryUrl - the url to the repository containing packages for checking and update
     * @param {String} opts.repositoryPath - short repository path of project to be processed
     * @param {String} opts.updateSourceTask - gulp task used to auto-update the source
     * @param {String} opts.updateSourceSummary - the summary description for the issue created to track source
     * update progress
     * @param {String} opts.updateSourceType - the issue type for the issue created to track source update progress
     * @param {Function} cb - callback function with signature: function(err, issue)
     */
    &quot;updateSource&quot;: function updateSource(opts, cb) {
      vasync.waterfall([
        function getNextUnreleasedPatchVersion(callback) {
          logger.info(&quot;JIRA get next unreleased path version for project: &quot; + opts.project.key);
          jiraUtils.getNextUnreleasedPatchVersion(opts.project.key,
            function getNextUnreleasedPatchVersionCallback(err, version) {
              callback(err, version);
            });
        },
        function createNewIssue(version, callback) {
          logger.info(&quot;JIRA create issue with version: v&quot; + version);
          jiraUtils.createIssue({
              &quot;key&quot;: opts.project.key,
              &quot;summary&quot;: opts.updateSourceSummary,
              &quot;issueType&quot;: opts.updateSourceType,
              &quot;version&quot;: version
            },
            function createIssueCallback(err, issue) {
              issue = issue || {}; //only id, key and selfURL properties returned
              issue.version = version;
              callback(err, issue);
            });
        },
        function transitionIssueToInProgress(issue, callback) {
          logger.info(&quot;JIRA transition issue to in progress: &quot; + issue.key);
          jiraUtils.transitionIssue(issue.key, &quot;11&quot;, function transitionIssueCallback(err) {
            callback(err, issue);
          });
        },
        function cloneFromGit(issue, callback) {
          var clone;
          if (!opts.updateCheck) {
            clone = opts.repositoryUrl + opts.repositoryPath;
            logger.info(&quot;GIT clone: &quot; + clone);
            execUtils.cloneFromGit(clone, opts.BUILD_DIR, null, function cloneFromGitCallback(err) {
              callback(err, issue);
            });
          } else {
            callback(null, issue);
          }
        },
        function runUpdateSourceTask(issue, callback) {
          logger.info(&quot;Gulp task: &quot; + opts.updateSourceTask);
          execUtils.runGulpTask(opts.updateSourceTask, process.cwd() + &quot;/&quot; + opts.BUILD_DIR,
            function runGulpTaskCallback(err) {
              callback(err, issue);
            });
        },
        function commitChanges(issue, callback) {
          var commit = issue.key + &quot; [Auto-update] &quot; + opts.updateSourceSummary;
          logger.info(&quot;GIT commit: &quot; + commit);
          execUtils.commitGit(commit, process.cwd() + &quot;/&quot; + opts.BUILD_DIR, function commitGitCallback(err) {
            callback(err, issue);
          });
        },
        function transitionIssueToQA(issue, callback) {
          logger.info(&quot;JIRA transition issue to QA: &quot; + issue.key);
          jiraUtils.transitionIssue(issue.key, &quot;71&quot;, function transitionIssueCallback(err) {
            callback(err, issue);
          });
        }
      ], cb);
    },


    /**
     * Transition issue to &quot;done&quot;, release a Jira project version, and if there are no unresolved issues
     * then trigger a release build.
     * @param {Object} issue - JIRA issue object map containing the properties `key` and `version`
     * @param {Object} workflowHistory - workflow history object map which will have following properties updated:
     * workflowHistory.transitionedIssue - true if issues transitioned to Done
     * workflowHistory.releasedVersion - JIRA version object map where property `released` will be true if there
     * are no unresolved issues
     * workflowHistory.bambooBuildResults - Bamboo build results object map
     * @param {Object} opts - options
     * @param {String} opts.project - JIRA project object map containing properties `key` and `name`
     * @param {String} opts.buildPlanName - Bamboo build plan name
     * @param {Function} cb - callback function with signature: function(err, result)
     */
    &quot;releaseBuild&quot;: function releaseBuild(issue, workflowHistory, opts, cb) {
      vasync.waterfall([
        function transitionIssueToDone(callback) {
          logger.info(&quot;JIRA transition issue to Done: &quot; + issue.key);
          jiraUtils.transitionIssue(issue.key, &quot;91&quot;, function transitionIssueCallback(err) {
            workflowHistory.transitionedIssue = true;
            callback(err);
          });
        },
        function releaseVersion(callback) {
          logger.info(&quot;JIRA release version: &quot; + opts.project.key + &quot; - v&quot; + issue.version);
          jiraUtils.releaseVersion(opts.project.key, issue.version, new global.Date(),
            function releaseVersionCallback(err, versionObj) {
              workflowHistory.releasedVersion = versionObj;
              callback(err, versionObj);
            });
        },
        function triggerReleaseBuild(versionObj, callback) {
          if (versionObj.released) {
            logger.info(&quot;Bamboo trigger release build: &quot; + opts.buildPlanName + &quot; - v&quot; + issue.version);
            bambooUtils.triggerBamboo(opts.buildPlanName, {
              &quot;jira.version&quot;: issue.version,
              &quot;jira.projectName&quot;: opts.project.name
            }, function triggerBambooCallback(err, buildResult) {
              workflowHistory.bambooRelease = buildResult;
              callback(err, versionObj, buildResult);
            });
          } else {
            callback(null, versionObj, null);
          }
        }
      ], cb);
    }
  };

  return exports;
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
