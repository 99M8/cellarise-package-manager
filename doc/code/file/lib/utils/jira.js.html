<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/utils/jira.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Cellarise/cellarise-package-manager.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/utils/jira.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;

/**
 * JIRA build utilities
 * @exports utils/jira
 * @returns {Object} JIRA build utility functions
 */
module.exports = function jiraUtils() {
  var oauthRest = require(&quot;oauth-rest-atlassian&quot;).rest;
  var _ = require(&quot;underscore&quot;);
  var config = require(&quot;./config&quot;)(&quot;jira&quot;);
  var vasync = require(&quot;vasync&quot;);

  var exports = {
    /**
     * Send query to rest api.
     * @param {Object} opts - required options
     * @param {Object} [opts.query] - the rest query url
     * @param {Object} [opts.method=&quot;get&quot;] - optional the http method - one of get, post, put, delete
     * @param {Object} [opts.postData=&quot;&quot;] - optional the post data for create or update queries.
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;rest&quot;: function rest(opts, cb) {
      opts = _.defaults(opts, {
        &quot;config&quot;: config
      });
      oauthRest(opts, cb);
    },

    /**
     * Get all JIRA projects.
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;getProjects&quot;: function getProjects(cb) {
      oauthRest({
        &quot;config&quot;: config,
        &quot;query&quot;: &quot;project&quot;
      }, cb);
    },

    /**
     * Create a JIRA issue.
     * @param {Object} issue - object map with properties required to create the issue
     * @param {String} issue.key - key for the JIRA project to create the issue within
     * @param {String} issue.summary - the summary description for the issue
     * @param {String} issue.issueType - the name of the issue type
     * @param {String} issue.version - the release version for the issue (fixversion)
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;createIssue&quot;: function createIssue(issue, cb) {
      //create update task in JIRA (non-func issue type) and get issue key
      oauthRest({
        &quot;config&quot;: config,
        &quot;query&quot;: &quot;issue&quot;,
        &quot;method&quot;: &quot;post&quot;,
        &quot;postData&quot;: {
          &quot;fields&quot;: {
            &quot;project&quot;: {
              &quot;key&quot;: issue.key
            },
            &quot;summary&quot;: issue.summary,
            &quot;issuetype&quot;: {
              &quot;name&quot;: issue.issueType
            },
            &quot;fixVersions&quot;: [
              {
                &quot;name&quot;: issue.version
              }
            ]
          }
        }
      }, cb);
    },

    /**
     * Delete a JIRA issue.
     * @param {String} key - the key for the JIRA issue to delete
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;deleteIssue&quot;: function deleteIssue(key, cb) {
      oauthRest({
        &quot;config&quot;: config,
        &quot;query&quot;: &quot;issue/&quot; + key,
        &quot;method&quot;: &quot;delete&quot;
      }, cb);
    },

    /**
     * Create a new version in a JIRA project.
     * @param {String} key - the JIRA project key
     * @param {String} version - the version (semver)
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;createVersion&quot;: function createVersion(key, version, cb) {
      oauthRest({
          &quot;config&quot;: config,
          &quot;query&quot;: &quot;version&quot;,
          &quot;method&quot;: &quot;post&quot;,
          &quot;postData&quot;: {
            &quot;project&quot;: key,
            &quot;name&quot;: version
          }
        },
        function createVersionCallback(err, data) {
          cb(err, data);
        });
    },

    /**
     * Delete an existing version in a JIRA project.
     * @param {String} key - the JIRA project key
     * @param {String} version - the version (semver)
     * @param {Function} cb - callback function with signature: function(err)
     */
    &quot;deleteVersion&quot;: function deleteVersion(key, version, cb) {
      vasync.waterfall([
        function getProjectVersions(callback) {
          oauthRest({
            &quot;config&quot;: config,
            &quot;query&quot;: &quot;project/&quot; + key + &quot;/versions&quot;
          }, callback);
        },
        function getVersionAndDelete(versions, callback) {
          var versionObj = _.find(versions, function matchVersion(v) {
            return v.name === version;
          });
          if (versionObj) {
            oauthRest({
              &quot;config&quot;: config,
              &quot;query&quot;: &quot;version/&quot; + versionObj.id,
              &quot;method&quot;: &quot;delete&quot;
            }, callback);
          } else {
            callback(&quot;Version &quot; + version + &quot; not found in project &quot; + key);
          }
        }
      ], cb);
    },

    /**
     * Release a version in a JIRA project.
     * The version will only be released if there are 0 unresolved issue linked to version.
     * @param {String} key - the JIRA project key
     * @param {String} version - the version (semver)
     * @param {Date} releaseDate - the release date
     * @param {Function} cb - callback function with signature: function(err, versionObj)
     * Where versionObj is an object with the following properties:
     * versionObj.id {String} - the version id
     * versionObj.name {String} - the version (semver)
     * versionObj.released {Boolean} - has the version been released
     * versionObj.releaseDate {String} - the planned (if released=false) or actual (if released=true) release date
     * versionObj.issuesUnresolvedCount {Number} - the number of unresolved issue linked to version
     */
    &quot;releaseVersion&quot;: function releaseVersion(key, version, releaseDate, cb) {
      //convert date to a string in format YYYY-MM-DD
      var releaseDateStr =
        releaseDate.getFullYear() + &quot;-&quot; +
        (&quot;&quot; + (releaseDate.getMonth() + 1)).slice(-2) + &quot;-&quot; +
        (&quot;0&quot; + releaseDate.getDate()).slice(-2);

      vasync.waterfall([
        function getProjectVersions(callback) {
          oauthRest({
            &quot;config&quot;: config,
            &quot;query&quot;: &quot;project/&quot; + key + &quot;/versions&quot;
          }, callback);
        },
        function getIssuesUnresolvedCount(versions, callback) {
          var versionObj = _.find(versions, function matchVersion(v) {
            return v.name === version;
          });
          if (versionObj) {
            oauthRest({
              &quot;config&quot;: config,
              &quot;query&quot;: &quot;version/&quot; + versionObj.id + &quot;/unresolvedIssueCount&quot;
            }, function getVersionCallback(err, data) {
              data = data || {};
              versionObj.issuesUnresolvedCount = data.issuesUnresolvedCount;
              callback(err, versionObj);
            });
          } else {
            callback(&quot;Version &quot; + version + &quot; not found in project &quot; + key);
          }
        },
        function releaseIfZeroIssuesUnresolved(versionObj, callback) {
          if (versionObj.issuesUnresolvedCount === 0) {
            oauthRest({
                &quot;config&quot;: config,
                &quot;query&quot;: &quot;version/&quot; + versionObj.id,
                &quot;method&quot;: &quot;put&quot;,
                &quot;postData&quot;: {
                  &quot;released&quot;: true,
                  &quot;releaseDate&quot;: releaseDateStr
                }
              },
              function getVersionCallback(err) {
                if (!err) {
                  versionObj.released = true;
                  versionObj.releaseDate = releaseDateStr;
                }
                callback(err, versionObj);
              });
          } else {
            //Note: versionObj.released will remain false
            callback(null, versionObj);
          }
        }
      ], cb);
    },

    /**
     * Transition a JIRA issue.
     * @param {String} key - key for the JIRA issue to transition
     * @param {String} transition - the transition id
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;transitionIssue&quot;: function transitionIssue(key, transition, cb) {
      oauthRest({
        &quot;config&quot;: config,
        &quot;query&quot;: &quot;issue/&quot; + key + &quot;/transitions&quot;,
        &quot;method&quot;: &quot;post&quot;,
        &quot;postData&quot;: {
          &quot;transition&quot;: {
            &quot;id&quot;: transition
          }
        }
      }, cb);
    },

    /**
     * Get the next unresolved and unreleased minor version for the project (based on semver).
     * If there is an existing unresolved and unreleased major or minor version then the earliest is returned.
     * @param {String} key - the JIRA project key
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;getNextUnreleasedPatchVersion&quot;: function getNextUnreleasedPatchVersion(key, cb) {
      var self = this;
      oauthRest({
        &quot;config&quot;: config,
        &quot;query&quot;: &quot;project/&quot; + key + &quot;/versions&quot;
      }, function getProjectVersionsCallback(err, versions) {
        var lastReleasedVersion = &quot;0.0.0&quot;;
        var nextUnreleasedPatchVersion = null;
        var releasedVersions;
        var unreleasedVersions;
        var lastReleasedVersionArray;

        if (!err) {
          if (versions.length &gt; 0) {
            //sort in semver order (assumes name of version is in semver format)
            versions = _.sortBy(versions, function semanticVersionSorter(version) {
              var versionArray = version.name.split(&quot;.&quot;);
              version =
                parseInt(versionArray[0], 10) * 1000000 +
                parseInt(versionArray[1], 10) * 1000 +
                parseInt(versionArray[2], 10);
              return version;
            });

            //get released versions
            releasedVersions = _.filter(versions, function releasedVersionFilter(version) {
              return version.released &amp;&amp; !version.archived;
            });
            //get latest released version
            if (releasedVersions.length &gt; 0) {
              lastReleasedVersion = releasedVersions[releasedVersions.length - 1].name;
            }

            //get unreleased versions
            unreleasedVersions = _.filter(versions, function unreleasedVersionFilter(version) {
              return !version.released &amp;&amp; !version.archived;
            });
            //get earliest patch version
            if (unreleasedVersions.length &gt; 0 &amp;&amp;
              parseInt(unreleasedVersions[0].name.split(&quot;.&quot;)[2], 10) &gt; 0) {
              nextUnreleasedPatchVersion = unreleasedVersions[0].name;
            }
          }

          if (nextUnreleasedPatchVersion === null) {
            //create new patch version
            lastReleasedVersionArray = lastReleasedVersion.split(&quot;.&quot;);
            nextUnreleasedPatchVersion =
              lastReleasedVersionArray[0] + &quot;.&quot; +
              lastReleasedVersionArray[1] + &quot;.&quot; +
              (parseInt(lastReleasedVersionArray[2], 10) + 1);

            self.createVersion(key, nextUnreleasedPatchVersion,
              function createVersionCallback(err2, version) {
                nextUnreleasedPatchVersion = null;
                if (!err2) {
                  nextUnreleasedPatchVersion = version.name;
                }
                cb(err2, nextUnreleasedPatchVersion);
              });
          } else {
            cb(err, nextUnreleasedPatchVersion);
          }
        } else {
          cb(err, nextUnreleasedPatchVersion);
        }
      });
    },

    /**
     * Get the changelog for a JIRA project.
     * @param {String} key - the JIRA project key
     * @param {Function} cb - callback function with signature: function(err, data)
     */
    &quot;getChangelog&quot;: function getChangelog(key, cb) {
      var self = this;
      var jiraQuery = &quot;search?jql=(project = &quot; + key + &quot; AND &quot; +
        &quot;issuetype in standardIssueTypes() AND issuetype != Task AND &quot; +
        &quot;resolution != Unresolved AND &quot; +
        &quot;fixVersion in (unreleasedVersions(), releasedVersions())) &quot; +
        &quot;ORDER BY fixVersion DESC, resolutiondate DESC&quot;;
      var queryFields =
        &quot;&amp;fields=*all&quot;;
      oauthRest({
        &quot;config&quot;: config,
        &quot;query&quot;: jiraQuery + queryFields
      }, function getChangelogCallback(err, data) {
        cb(err, self.prepareChangeLogJSON(data));
      });
    },

    /**
     * Tranform raw changelog data from a JQL query into a JSON object.
     * @param {Object} data - raw changelog data
     * @returns {Object} changelog JSON object
     * @example
     Raw changelog data:
     ```
     {
     &quot;releases&quot;: [
         {
           &quot;version&quot;: {
             &quot;self&quot;: &quot;https://jira.cellarise.com/rest/api/2/version/10516&quot;,
             &quot;id&quot;: &quot;10516&quot;,
             &quot;name&quot;: &quot;0.1.4&quot;,
             &quot;archived&quot;: false,
             &quot;released&quot;: true,
             &quot;releaseDate&quot;: &quot;2014-08-28&quot;
           },
           &quot;issues&quot;: []
         }
     }
     ```
     */
    &quot;prepareChangeLogJSON&quot;: function prepareChangeLogJSON(data) {
      var changeLogJSON = {
          &quot;releases&quot;: []
        },
        i,
        issues,
        currentIssue,
        currentVersion,
        release,
        releaseNum = -1,
        date = new Date();

      if (!data) {
        return {};
      }

      issues = data.issues;

      for (i = 0; i &lt; issues.length; i = i + 1) {
        currentIssue = issues[i];
        currentVersion = currentIssue.fields.fixVersions[0];
        //first version or check for change in version
        if (!release || release.name !== currentVersion.name) {
          //check if version date set, otherwise set to current date
          if (!currentVersion.releaseDate) {
            currentVersion.releaseDate = date.getFullYear() + &quot;-&quot; +
              (&quot;0&quot; + (date.getMonth() + 1)).slice(-2) + &quot;-&quot; +
              (&quot;0&quot; + date.getDate()).slice(-2);
          }
          release = currentVersion;
          releaseNum = releaseNum + 1;
          changeLogJSON.releases[releaseNum] = {
            &quot;version&quot;: currentVersion,
            &quot;issues&quot;: []
          };
        }
        //add issue to release
        changeLogJSON.releases[releaseNum].issues.push({
          &quot;key&quot;: currentIssue.key,
          &quot;summary&quot;: currentIssue.fields.summary,
          &quot;description&quot;: currentIssue.fields.description,
          &quot;issuetype&quot;: currentIssue.fields.issuetype,
          &quot;status&quot;: currentIssue.fields.status,
          &quot;priority&quot;: currentIssue.fields.priority,
          &quot;resolution&quot;: currentIssue.fields.resolution,
          &quot;components&quot;: currentIssue.fields.components,
          &quot;resolutiondate&quot;: currentIssue.fields.resolutiondate
        });
      }
      return changeLogJSON;
    }
  };

  return exports;
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
